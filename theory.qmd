# Theory {.unnumbered}

::: {#theo}
:::

## Some History...

The development of a framework for CDT process scheduling is rooted in the _job scheduling problems_ that emerged with industrialization and assembly-line work. It is not a coincidence that many of the classical scheduling problems have names like Job Shop Problem or Flow Shop Problem. Back then and now the targets are the same: execute complex jobs that might need treatment on different machines in a defined sequential orders with certain degrees of efficiency. Efficiency in this context can be defined in a number of ways. It might be the total time needed to execute a set of jobs, the compliance of given deadlines, the minimization of overall costs or a combination of all the above.

There are two ways to view the the Continuum Digital Twin^[CDT]:

1. Facility- or Machine-centered view.
2. Job-centered view.

The first is best modelled by a _supply chain_ model.  The second is principally a _scheduling_ approach.

::: {#fig-SC_SCHED}
![](graphics/sc-sched.svg){width=100%}

Two different viewponts of the CDT: a supply chain model (left) and a scheduling model (right). DC = data center, CC = compute center, J = job.
:::

We propose a _combined_ model for the CDT, composed of a Supply Chain Network Design^[SCND] coupled with a Resource Constrained Process Scheduling^[RCPSP]. In such a hierarchical system, the supply chain model allocates jobs to the best facilities, and the scheduling model then (optimally) sequences jobs among facilities and within a given facility. Supply chain optimization emphasizes "where" (facility choice, data transfer mode). Scheduling emphasizes "when" and "in what order."


Recall the basic problem: given a directed graph of $N$ data storage, transfer and processing jobs $\mathscr{J},$[$\mathscr{J}=\{ J_1, J_2, \ldots J_N\},$]{.column-margin} find an optimal allocation $A$ and a feasible schedule $S.$ Further details below.

## Supply Chains with Scheduling

Let us begin by defining supply chains and scheduling in the context of the CDT.

::: {#def-supp}
## Supply Chain
A _supply chain_ is a network (directed graph)  of jobs, facilities, data storage, networks, processing and end-product delivery to users. The design poroblem is to optimally allocate an ordered list of data storage and data processing jobs to an optimal choice of storage and processing centres.
:::


::: {#def-sched}
## Scheduling
_Scheduling_ is a decision-making process that deals with the
allocation of (limited) resources to tasks over given time periods.
Its goal is to optimize one or more objectives. The resulting  _schedule_
is a job sequence determined for every machine (facility) of the processing system.
:::

These two models are complementary:

- the SCND can be used for global, over a _fixed period_, modelling---for example over an entire project duration, or annualized;
- the RCPSP can be used for time-dependent models, especially when uncertainty is introduced, as in a two-stage, or multi-stage, model---see below Section @sec-stoch.

In @fig-wf and @fig-wf2 below, we show the two alternative viewpoints of a simple 4-job, 4-machine scheduling problem. The global mathematical formulation will effectively include and  _combine_ these two viewpoints, as depicted in @fig-CDT_RCP_SC and formulated below.

::: {#fig-wf}
```{mermaid}
graph LR
    A[0] -->|"$$c_{0,1}$$"| B("$$J_1$$")
    B -->|"$$c_{1,2}$$"| C("$$J_2$$")
    C -->|"$$c_{2,3}$$"| D("$$J_3$$")
    C -->|"$$c_{2,4}$$"| E("$$J_4$$")
    D -->|"$$c_{3,5}$$"| F[5]
    E -->|"$$c_{4,5}$$"| F

```
Job-centered view: A simple directed graph (DAG) for a genomics workflow with 4 processing jobs $J_1,\cdots, J_4,$ and data transfers $c_{i,j}$ between them, including initial upload and final download. The tasks 0 and 5 are dummy tasks, representing the start and the end of the workflow.
:::

::: {#fig-wf2}
```{mermaid}
flowchart LR
    A[(DC1)]:::otherclass --> C{{HPC1}}:::thirdclass
    B[(DC2)]:::otherclass 
    A --> D{{HPC2}}:::thirdclass
    %%A[(data1)]:::someclass --> E{{HPC3}}:::thirdclass
    C --> F[(DC1)]:::otherclass
    C --> G[(DC2)]:::otherclass
    F --> H{{HPC1}}:::thirdclass
    F --> I{{HPC2}}:::thirdclass  
    classDef someclass stroke:#f00
    classDef otherclass stroke:#0f0
    classDef thirdclass stroke:#00f

```
Machine-centered view: Supply chain model for the CDT. For a given job, the dataset (stored in one of two Datacentres, $\mathrm{DC}_1$ or $\mathrm{DC}_2$) can be processed on one of two HPC centres ($\mathrm{HPC}_1$ or $\mathrm{HPC}_2$), and ouput data is sent to (and stored on) one of the two Datacentres, ready as input for the next job. This is repeated for each job in the ordered job list (DAG).
:::

::: {#fig-CDT_RCP_SC}
![](graphics/CDT_RCP_SC.svg){width=40%}

The CDT model is based on RCPSP and SCND.
:::


## Supply Chain Network Design with Resource Constrained Scheduling

### Problem Definition

The resource-constrained project scheduling problem is a classical, well-known problem in operations research, and started with  the CPM^[Critical Path Method] that was developed in the 1950's. A number of activities are to be scheduled. Each activity has a duration and cannot be interrupted. There are a set of precedence relations between pairs of activities which state that the second activity must start after the first has finished. 

The set of precedence relations are usually given as a directed acyclic graph (DAG), where the edge $(i,j)$ represents a precedence relation where job $i$ must finish before job $j$ begins. The DAG contains two additional dummy activities with duration 0, the source and sink, where the source is the first activity and the sink is the last activity.

There are also sets of _renewable resources_ and _non-renewable resources._ Each resource has a maximum capacity and at any given time slot no more than this amount can be in use. Each activity has a demand (possibly zero) on each resource. The dummy source and sink activities have zero demand on all resources.

_Multi-Mode Variant_
 The multi-mode resource-constrained project scheduling problem^[MRCPSP] is an extension of the resource-constrained project scheduling problem where each task can be executed in one of a number of alternative modes. The problem aims to select a single task mode from a set of available modes in order to construct a precedence- and resource-feasible project schedule with a minimal makespan. This is similar to a supply chain. 

_Non-Renewable Resources_
Another extension concerns non-renewable resources. Each non-renewable resource has a capacity for the entire schedule. An example would be a financial, or human resources budget that applies to the entire project. Modes of activities must be chosen to avoid exceeding the total capacity of each of the non-renewable resources. 

_Time Windows_
Instead of optimizing over the maximum value of the project timespan, we can use time windows. The benefit of time windows is twofold: first, they can be used in the mathematical programming formulation to reduce the number of variables substantially, i.e. they provide a tighter formulation. Second, they can be utilized in several enumeration procedures to speed up the convergence of the underlying optimization algorithms. 

### State Variables

The state of the system at a given time $t,$ is represented by a set of _binary-valued_ state variables that designate the facilities that are used, at each stage, by each job to be performed in the workflow.

### Objective Function

The overall objective is to combine location decisions---which centres to use---with allocation
decisions---how to distribute the workloads and jobs among the chosen centres (data and compute). Various project _performance metrics_ can be optimized, including task-based, resource-based, financial-based and user-based metrics. One can minimize makespan, tardiness, resource consumption, or maximize total NPV with respect to sustainability, for example. 

There can be a _single_ objective such as minimizing (any function of) the total of fixed and variable costs, or minimizing the completion time (makespan). _Multiple_ objective optimization^[MOO] seeks a tradeoff between minimum cost and  maximum sustainability (minimum environmental impact). Finally, _stochastic_ optimization takes into account the uncertainties of resource availabilities and delays, maintenance and failures, resource allocations, variable energy costs, project costs (HR, budget).

The overall, deterministic cost function can be expressed either as a bottleneck objective, where we seek to minimize the longest or most expensive job, or as a weighted sum over all jobs of makespan, cost and any functions of these.^[Some terms can be ignored by setting the coefficients to zero, depending on the context.]


For example, suppose we have $m$ machines $\{M_j\}_{j=1}^{m}$ to process $n$ jobs $\{J_i\}_{i=1}^{n}.$ A job $J_i$ can eventually be broken down into  $n_i$ operations $O_{i1},\ldots,O_{in_i},$ each with its own processing requirement $p_{ij}.$

_Objective Functions_ Denote the finishing time of job $J_i$ by $C_i$ and the associated cost $f_i(C_i).$ Then there are two types of total cost functions, the _bottleneck_ objective
$$
   f_{\mathrm{max}}(C) \doteq \max \{f_i(C_i) \mid i=1,\ldots,n\}
$$
and the _sum_ objective
$$
   \sum f_i(C) \doteq  \sum_{i=1}^{n} f_i(C_i).
$$
The sum can also be weighted, if required. 


### Mathematical Formulation - Deterministic Model {#sec-math}

 **Resource-Constrained Project Scheduling Problem (RCPSP)**

The Resource-Constrained Project Scheduling Problem (RCPSP) is an NP-hard combinatorial
optimization problem that consists of finding a feasible scheduling
for a set of $n$ jobs subject to resource and precedence constraints.
Each job has a processing time, a set of successor jobs and a required
amount of different resources. Resources may be scarce but are renewable
at each time period. Precedence constraints between jobs mean that
no jobs may start before all its predecessors are completed. The jobs
must be scheduled non-preemptively, i.e., once started, their processing
cannot be interrupted.


The RCPSP has the following input data:

- $\mathcal{J} = \{J_1, J_2, \ldots, J_n \}$ set of jobs.
- $\mathcal{R}$ set of renewable resources. 
- $\mathcal{S}$ set of precedences^[These can be rigorously defined using an order relation, $i \prec j$.] between jobs $(i,j)\in\mathcal{J}\times\mathcal{J}.$
- $\mathcal{T}$ planning horizon: set of possible processing times
for jobs.
- $p_{j}$ processing time of job $j.$
- $u_{jr}$ amount of (renewable) resource $r$ required for processing job $j.$
- $c_{r}$ capacity of renewable resource $r.$

There are many different Mixed Integer Linear Programming (MILP) formulations for the RCPSP. We choose the most suitable, discrete-time (DT) formulation^[An alternative formulation, based on _disjunctions_ will be presenetd in the Examples---see @sec-exam.]. This is a binary formulation where we have a binary variable $x_{i,t}$ for each activity $i$ and starting time/date $t,$  $$ x_{i,t} = \begin{cases} 1, \quad \text{if activity $i$ starts on day/time $t,$} \\ 0, \quad  \text{otherwise.}  \end{cases} $$ 

The binary programming formulation, proposed by Pritsker et al. in
1986 can be written as follows.

$$
\begin{align}
\text{Minimize} \quad &  \sum_{t\in \mathcal{T}} t\cdot x_{n+1,t} & (1)\\
\text{Subject to:} \quad & 
 \sum_{t\in \mathcal{T}} x_{j,t}  = 1  \,\,\, \forall j\in J & (2)\\
 & \sum_{j\in J} \sum_{t_2=t-p_{j}+1}^{t} u_{jr}x_{j,t_2}  \leq c_{r}  \,\,\, \forall t\in \mathcal{T}, r \in R & (3) \\
 & \sum_{t\in \mathcal{T}} t\cdot x_{s,t} - \sum_{t \in \mathcal{T}} t\cdot x_{j,t}  \geq p_{j}  \,\,\, \forall (j,s) \in S & (4)\\
& x_{j,t}  \in \{0,1\} \,\,\, \forall j\in J, t \in \mathcal{T} & (5)
\end{align}$$

The objective function (1) represents the sum of all possible start dates for the final sink job (dummy variable) $x_{n+1,t}.$ We know that only one of these variables will equal 1 for a specific $t.$ Therefore, by minimizing the sum of the product $t \cdot x_{n+1,t},$ we are effectively minimizing the total project duration. Constraint (2) ensures that each activity $i$ has exactly one start date, i.e. a single execution. Constraint (3) guarantees that for any time period $t,$ the schedule does not exceed the capacity $R_k$ for any resource $k.$
Finally, constraint (4)  ensures that if an activity $j$ follows another activity $i,$ then activity $j$ must start after the finish time of activity $i,$ which is equal to the start time of activity $i$ plus its duration $p_i.$

**Mutli-Project Multi-Mode RCPSP**

Note that the above formulation is restricted to temporal scheduling on a _single_ machine, and for a single project---a collection of jobs. This formulation can be generalized to deal with multiple machines and multiple projects. In this case, the formulation becomes very similar to that of a supply chain. It is referred to in the literature as the  _multi-mode resource-constrained multi-project scheduling problem_, or MRCMPSP. 

**Multi-Mode**
The single-mode RCPSP assumed that each activity has only one way to be executed, whereas the multi-mode RCPSP considers multiple ways to execute an activity, which often have tradeoffs in duration, cost, or resource requirement.

Let the decision variable $x_{jm,t} \in \{0,1 \}$ denote the execution of job $j$ in mode $m$ completed in period $t.$ Then the  MRCPSP with tight, time-indexed formulation^[A disjunctive formulation, based on XOR relations, is also possible---see @sec-exam] can be written as: 

$$
\begin{align}
\min \quad &  \sum_{t=\mathrm{EF}_J}^{\mathrm{LF}_J} t\cdot x_{J1,t} & (1)\\
\text{s.t.} \quad & 
 \sum_{m=1}^{M_j}  \sum_{t=\mathrm{EF}_J}^{\mathrm{LF}_J} x_{jm,t}  = 1,  \,\,\, j=1,\ldots, J ,& (2)\\
 & \sum_{m=1}^{M_j} \sum_{t=\mathrm{EF}_h}^{\mathrm{LF}_h} t \cdot x_{hm,t} \le \sum_{m=1}^{M_j}\sum_{t=\mathrm{EF}_j}^{\mathrm{LF}_j} (t - p_{jm}) \cdot x_{jm,t},  \,\,\, j=2,\ldots, J, \, h \in \mathcal{P}_j , & (3)\\
 & \sum_{j=2}^{J-1} \sum_{m=1}^{M_j} k_{jmr}^{\rho} \sum_{q=\max\{t,\mathrm{EF}_j\} }^{\min \{ t+p_{jm}-1,\mathrm{LF}_j \}}  x_{jm,q} \le K_r^{\rho}, \,\,\,  r\in R^{\rho}, \, t=1,\ldots, \bar{T}, & (4) \\
& \sum_{j=2}^{J-1} \sum_{m=1}^{M_j} k_{jmr}^{\nu}   \sum_{t=\mathrm{EF}_J}^{\mathrm{LF}_J}  x_{jm,t} \le K_r^{\nu}, \,\,\, r\in R^{\nu},  & (5)\\
& x_{jm,t}  \in \{0,1\}, \,\,\, j=1,\ldots,J, \, m=1,\ldots ,M_j, \, t =0,\ldots, \bar{T}, & (6)
\end{align}$$
where $\mathcal{P}_j$ is the set of predecessors of job $j,$  the earliest finish and latest finish times of job $j$ are denoted $\mathrm{EF}_j,$ $\mathrm{LF}_j,$ an upper bound on the project's makespan is given by $\bar{T}$, and we have denoted renewable resources by the index $\rho$ and non-renewables by $\nu.$

Note that objective (1) is the minimization of the makespan^[To which we can add any cost function of the duration.], the constraints (2) indicate that each activity is assigned exactly one mode and exactly one finish time, (3) ensures that no activity is started until all its predecessors are finished, (4) ensures that the per-period levels of the renewable resources are met,  and consumption of the nonrenewable resources is limited to their availabilities by (5). Finally, restricting the summations^[This produces what is known as a _tighter_ formulation.] over time to the intervals $[\mathrm{EF}_j, \mathrm{LF}_j]$ reduces drastically the number of variables and gives better convergence. These time windows can be computed by simple forward and backward recursion loops.

**Multi-Objective**
To include infrastructure costs in the objective function, we just add a term^[Or terms, if other costs are to be taken into account, e.g. related to sustainability] 
$$\begin{align}
\min \quad &  \sum_{t=\mathrm{EF}_J}^{\mathrm{LF}_J} t\cdot x_{J1,t} 
                  + \sum_{j,m} c_{jm} x_{jm} & (1')\\
\end{align}$$
where $c_m$ is the cost associated with the use of facility $m$ for task $j.$

**Multi-Project**
We can also perform simultaneous scheduling of a set of multiple projects taking into account the availability of local and global resources under different time and resource constraints. This has practical importance, at national and European levels, when cross-facility implies exploitation of cyberinfrastructure resources across different countries, for example, as would be the case for EuroHPC^[ [https://www.eurohpc-ju.europa.eu/](https://www.eurohpc-ju.europa.eu/) ], at the European level, or GENCI^[ [https://www.genci.fr//](https://www.genci.fr/) ] for France. Imagine being able to plan and pilot multiple exascale projects, on multiple sites, over multiple countries...^[These would be multiple states, in the USA context.]



**Conclusion**
This general formulation of the RCPSP is then mathematically equivalent to the supply chain configuration problem^[SCCP] with the addition of resource constraints. The loop is closed.


## Dynamic Networks

We can generalize the supply chain by considering a multi-stage network with an added  time dimension. This enables flow and carrying of data and jobs across time periods, in addition to flow among facilities. For example, if certain facilites become unavailable, or less available, as the project evolves over time. This is a kind of recourse, which will be considered below in Section @sec-stoch.

::: {#fig-wf3}
```{mermaid}
flowchart LR
    subgraph t1["t = 1"]
    direction LR
    a1((" "))-->a2((" "))
    a1-->a3((" "))
    a2-->a4((" "))
    a2-.->a5((" "))
    end
    subgraph t2["t = 2"]
    direction LR
    b1((" "))-->b2((" "))
    b1-->b3((" "))
    b2-.->b4((" "))
    b2-->b5((" "))
    end
    t1 --> t2
    style t1 fill: white
    style t2 fill: white
```
Multi-stage, dynamic network that evolves over time due to changing availability constraints.
:::


## Uncertainty {#sec-stoch}

In practice some of the scheduling parameters may be uncertain. The exact duration of an activity, for instance, might not be known at the beginning of the project. Similarly, the number of available resources is another parameter that may not be known before project execution. These uncertainties may be due to different sources, including estimation errors, unforeseen (weather) conditions, late "delivery" (unavailability) of some required resources, unpredictable incidents such as machine breakdown or worker accidents, etc. 

### Stochastic, multistage programming

**Background**

Stochastic programming/optimization (optimal decision-making under
uncertainty) is the part of mathematical programming and operations
research that studies how to incorporate uncertainty into decision
problems. Stochastic programs are primarily about transient decision
making.

<div class="warning" style='background-color:#E9D8FD; color: #69337A; border-left: solid #b199e4 4px; border-radius: 4px; padding:0.7em;'>
<span>
<p style='margin-top:1em; text-align:center'>
<b>Information:</b></p>
<p style='margin-left:1em;'>
Some decisions must be made today, but important information will not be available until after the decision is made.
</p>
</div>

An _information stage_ (normally simply called “stage”)
is the most important concept that distinguishes stochastic programming.  A stage is a point in time where decisions are made within a model. Stages define the boundaries of time intervals. Stages sometimes follow naturally from the problem setting and sometimes are modeling approximations.


The starting point of a stochastic program is the present situation.
The model is intended to tell us what to do in light of our goals,
constraints, and resources. We then ask what we should do. We are not asking what to do in all
possible situations, just what to do based on our present state.

- An inherently _two-stage model_ is a model where
the first decision is a major long-term decision, whereas the remaining
stages represent the use of this investment. In these cases, mathematically
speaking, the first stage will look totally different from the remaining
stages, which will all look more or less the same. This is a very
important class of models, possibly the most important one for stochastic
programming.
- In inherently _multistage models_, all stages
are of the same type. We face random resource availability, energy prices, unexpected maintenance, etc.
We should not confuse information stages with time periods. Stages model the flow of
information; time periods represent the ticking of the clock in a
model. Stages, on the other hand, are points in time where
we make decisions in the model after having learned something new.

Finding a good trade-off between time periods
and stages is often crucial when modeling, as it has consequences
for model quality, data collection, and solvability of the model. 

<div class="warning" style='background-color:#E9D8FD; color: #69337A; border-left: solid #805AD5 4px; border-radius: 4px; padding:0.7em;'>
<span>
<p style='margin-top:1em; text-align:center'>
<b>Warning/Fact:</b></p>
<p style='margin-left:1em;'>
In the long run we are all dead.
</p>
<p style='margin-bottom:1em; margin-right:1em; text-align:right; font-family:Georgia'> <b>- John Maynard Keynes</b> <i>(A Tract on Monetary Reform, 1923)</i>
</p></span>
</div>

In other words, one should not wait too long before taking a decision.

**Mathematical Formulation**

::: {#fig-sdp}
![](graphics/sdp.png){width=80%}

A multistage decision process with uncertainty. Uncertain, exogenous inputs $\xi_t$ arrive, starting from stage $t=2,$ and trigger subsequent recourse actions.
:::

In the Figure we depict a generic multistage  decision process with state $\mathbf{x}_t$ that evolves over time, starting at stage $t=1,$ and then receives uncertain, exogenous inputs, $\xi_2, \xi_3, \ldots, \xi_T,$ at given stages $t = 2,3,\ldots, T.$ At stage 1, a here-and-now (deterministic) decision is taken. The subsequent sequence of wait-and-see decision functions ${\mathbf{x}_t(\xi_t)}_{t\in [T]}$ constitutes a _policy_, $\pi.$ The policy thus obtained, provides a decision rule for all stages $t \in [T].$ The aim of the decision process (stochastic multistage optimization) is then to compute an _optimal policy_  for a given objective and subject to constraints.

We will describe in detail the two-stage problem, since the multistage is a straightforward generalisation.  In the stochastic setting, we can naturally classify $x\in\mathscr{X}$ as the _first-stage_ decision variables, since the initial facilities^[Data centers, HPC centers, networks. ] are fixed and $y\in\mathbb{R}^{\left|\mathscr{A}\right|\times\left|\mathscr{K}\right|}$ as the _second-stage_ decision variables, since the job-flow operating conditions are uncertain over time.

The two-stage stochastic linear program [@birgelouveaux2011], [@shapiro_lectures_2009] is then

$$\begin{align} \label{eq:2stage}
\min_{x\in\mathscr{X}} & \,\,c^{\top}x + \mathrm{E}\left[Q(x;\xi)\right],
\end{align}$$
where $Q(x;\xi)$ is the optimal value of the second-stage problem
$$\begin{align*}
\min_{y\ge0} & \,\,q^{\top}y\\
\textrm{s.t.} & \,\,Ny=0,\\
 & Cy\ge d,\\
 & Sy\le s,\\
 & Ry\le Mx,
\end{align*}$$
where $d$ is the (uncertain) resource demand, $s$ is the (uncertain) resource supply, the random vector $\xi=(q,d,s,R,M)$ and $y=y(\xi).$ The expectation is taken with respect to the joint probability distribution function^[Either continuous or discrete, it is derived either from theory or observations, or both.] of $\xi.$  In the terminology of state-space, we can consider $x$ as the _state_ variable, and $y$  as the _control_ variable.

To treat the occurrence of infeasibility, where the first-stage solution
does not satisfy the second-stage constraints, e.g. $Cy\nleqslant d,$
we  introduce a _recourse_ action $z$  that supplies
the deficit $d-Cy$ at some penalty cost. Then the second-stage problem becomes
$$\begin{align*}
\min_{y\ge0} & \,\,q^{\top}y+h^{\top}z\\
\textrm{s.t.} & \,\,Ny=0,\\
 & Cy+z\ge d,\\
 & Sy\le s,\\
 & Ry\le Mx,
\end{align*}$$
where $h$ represents the vector of (positive) recourse costs.



In the multistage case, we will have a succession of recourse stages, yielding the multistage program [@powell2022], 

$$
    \min_{\pi \in \Pi} \mathrm{E} \left[ \sum^{T}_{t=1} \gamma^{t-1} f_t(x_t;\xi_t) \right],
$$
subject to
$$
     x_t \in \mathcal{X}_t(x_{t-1};\xi_{t-1}), \quad t=1 \ldots, T,
$$
where $\pi$ is a policy, $\gamma$ is a discount factor, $f_t$  is a cost function, $x_t$ is a decision and $\mathcal{X}_t$ are the constraints. A policy is, by definition, a method that optimizes the objective. For example, in Google maps, the policy is to decide whether to turn left or right by optimizing over the time required to transverse the next link in the network plus the remaining time to get to the destination.


Note that there are various forms of minimization in stochastic scheduling.  Whenever an objective function has to be minimized, it has to be specified in what sense the objective has to be minimized. 

- _Expectation_ sense is the crudest form of optimization,
e.g., one wishes to minimize (a function of) the expected makespan,
that is $\mathrm{E}\left[f\left(C_{\mathrm{max}}\right)\right],$
and find a policy under which the expected makespan is smaller than
the expected makespan under any other policy. 
- _Stochastic_ sense is a stronger form of optimization.
If a schedule or policy minimizes $f\left(C_{\mathrm{max}}\right)$
stochastically, then the makespan under the optimal schedule or policy
is stochastically (in probability, or in law) less than the makespan under any other schedule
or policy. 
