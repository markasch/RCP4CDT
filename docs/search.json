[
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Implementation",
    "section": "",
    "text": "Basic pyomo Linear Programming Example\nThis section details all the practical aspects of the optimal CDT scheduling. We intentionally provide a very general framework, but illustrate it with several simple examples.\nAs an introduction we load the necessary pyomo packages and solve an ultra-simple linear programming example. \\[\n\\begin{array}{ll}\n  \\min       & 2 x_1 + 3 x_2\\\\\n  \\mathrm{s.t.} & 3 x_1 + 4 x_2 \\geq 1\\\\\n             & x_1, x_2 \\geq 0\n\\end{array}\n\\]\nimport pyomo.environ as pyo \nfrom pyomo.opt import SolverFactory \n\nmodel = pyo.ConcreteModel(\"Simple Linear\")\n# Decision variables and domains\nmodel.x = pyo.Var([1,2], domain=pyo.NonNegativeReals)\n# Objective function\nmodel.OBJ = pyo.Objective(expr = 2*model.x[1] + 3*model.x[2])\n# Constraint(s)\nmodel.Constraint1 = pyo.Constraint(expr = 3*model.x[1] + 4*model.x[2] &gt;= 1)\n\nsolver = 'appsi_highs'\nSOLVER = pyo.SolverFactory(solver)\nassert SOLVER.available(), f\"Solver {solver} is not available.\"\n\n# Solve and print solution\nSOLVER.solve(model)\nprint(f\"x = ({pyo.value(model.x[1]):.2f}, {pyo.value(model.x[2]):.2f})\")\nprint(f\"optimal value = {pyo.value(model.OBJ):.2f}\")\n\nx = (0.33, 0.00)\noptimal value = 0.67\nWe can print out",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#cdt-implementation",
    "href": "examples.html#cdt-implementation",
    "title": "Implementation",
    "section": "CDT Implementation",
    "text": "CDT Implementation\nBefore addressing the simple examples of resource scheduling and the use cases, we describe the overall implementation, as shown in Figure 2.1.\n\n\n\n\n\n\n\n\nflowchart LR\n    A[/Input/] --&gt; B[\"Model \n                      Function\"]\n    B --&gt; C[\"pyomo\n             Model\"] \n    C --&gt; D[/Schedule /]\n\n\n\n\n\n\n\n\nFigure 2.1: The implementation in 4 stages.\n\n\n\n\nInput description of jobs (json file), that is loaded into …\nModel function, that generates …\npyomo model, which produces …\nOutput, an optimal schedule (csv file).\n\n\nInput File\nThis json input file contains a complete description of the CDT that we want to model for optimization. Thanks to its genericity, it can be readily adapted to a wide diversity of projects, and even to global job scheduling at national or European levels.\nThe input file contains all the information regarding the following characteristics of the CDT:\n\n\\(\\mathcal{P} = \\{P_1, P_2, \\ldots \\}\\) the list of projects;\n\\(\\mathcal{J}_i = \\{J_1^i, J_2^i, \\ldots \\}\\) the list of jobs per project1;\n\\(\\mathcal{O}_j = \\{O_1^j, O_2^j, \\ldots \\}\\) the list of operations per job2;\n\\(\\mathcal{M}_k = \\{M_1^k, M_2^k, \\ldots \\}\\) the list of modes per job (operation)3;\nResources:\n\n\\(\\mathcal{R}_l^{\\rho} = \\{R_1^l, R_2^l, \\ldots \\}\\) list of renewable resources per mode;\n\\(\\mathcal{R}_l^{\\nu} = \\{R_1^l, R_2^l, \\ldots \\}\\) list of non-renewable resources per project;\n\nJob requirements per resource: \\(p_{ij}\\)\nCosts per resource: \\(c_{ij,l}\\)\nList of precedences4: \\(\\mathcal{E} = \\{(i,j) \\mid i \\prec j, \\, i,j \\in \\mathcal{J} \\}.\\)\n\n1 These are of type data transfer, data storage, data processing, etc.2 This is an optional sub-group–the operations can just be considered as additional jobs.3 These are the facilities that can be exploited for each category of job: networks, data centers, HPC centers, etc.4 Successors and/or predecessors, as defined by the workflow DAG.",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#simplified-supply-chain-example",
    "href": "examples.html#simplified-supply-chain-example",
    "title": "Implementation",
    "section": "Simplified Supply Chain Example",
    "text": "Simplified Supply Chain Example\nPutting together:\n\nprecedence\nTBC",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#simplified-rcpsp-example",
    "href": "examples.html#simplified-rcpsp-example",
    "title": "Implementation",
    "section": "Simplified RCPSP Example",
    "text": "Simplified RCPSP Example\nPutting together:\n\nprecedence\ntime-indexed\ndisjunctive",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#simplified-mrcpsp-example",
    "href": "examples.html#simplified-mrcpsp-example",
    "title": "Implementation",
    "section": "Simplified MRCPSP Example",
    "text": "Simplified MRCPSP Example\nIn this example we have 4 jobs, 2 possible modes, 1 renewable resource and no non-renewable resources. Jobs 2 and 3 can be executed in mode 1 or in mode 2.\n\n\n\n\n\n\n\n\ngraph LR\n    A[\"$$J_0$$\"] --&gt; B(\"$$J_1$$\")\n    A --&gt; C(\"$$J_2$$\")\n    B --&gt; D(\"$$J_3$$\")\n    C --&gt; E(\"$$J_4$$\")\n    D --&gt; F[\"$$J_5$$\"]\n    E --&gt; F\n\n\n\n\n\n\n\n\n\nFigure 1.2: A project network represented as a directed acyclic graph (DAG) for a workflow with 4 processing jobs \\(J_1,\\cdots, J_4.\\) The tasks 0 and 5 are dummy tasks, representing the start and the end of the workflow.\n\n\n\nThe project instance, shown above, is detailed in Table 1, where \\(S_j\\) is the successor list of job \\(j,\\) \\(m\\) is the mode, \\(d_{jm}\\) is the job duration, \\(k^{\\rho}_{jm1}\\) is the renewable resource requirement, \\(R^{\\rho}\\) is the renewable resource list, \\(K^{\\rho}\\) is the renewable resource limit, and \\(R^{\\nu}\\) is the non-renewable resource list, taken as empty. In other words we have 4 jobs, 2 possible modes, 1 renewable resource and no non-renewable resources. Jobs 2 and 3 can be executed in mode 1 or in mode 2.\n\\[\\begin{aligned}\n& \\text {Table 1. Multi-mode RCPSP for a 4-job, 2-mode workflow. }\\\\\n&\\begin{array}{cccccccc}\n%\\begin{tabular}{|c|c|c|c|c|c|c|c|}\n\\hline\nj & S_{j}& m & d_{jm} & k^{\\rho}_{jm1} & R^{\\rho} & K^{\\rho}_{1} & R^{\\nu}\\\\\n\\hline\n0 & \\left\\{ 1,2\\right\\}  & 1 & 0 & 0 & \\left\\{ 1\\right\\}  & 3 & \\emptyset \\\\\n1 & \\left\\{ 3\\right\\}  & 1 & 2 & 2  &  &  & \\\\\n2 & \\left\\{ 4\\right\\}  & 1 & 2 & 2 &  &  & \\\\\n&  & 2 & 3 & 1 &  &  & \\\\\n3 & \\left\\{ 5\\right\\}  & 1 & 1 & 3 &  &  & \\\\\n&  & 2 & 2 & 1 &  &  & \\\\\n4 & \\left\\{ 5\\right\\}  & 1 & 2 & 3 &  &  & \\\\\n5 & \\emptyset & 1 & 0 & 0 &  &  & \\\\\n\\hline\n%\\end{tabular}\n\\end{array}\n\\end{aligned}\\]\nInput File\nThe input file is a direct transcription of the table of variables.\n{\n  \"0\":{\"suc\":(\"1\",\"2\"),\"mod\":\"A\",\"drt\":0,    \"rsc\":0},\n  \"1\":{\"suc\":\"3\",\"mod\":\"A\",      \"drt\":2,    \"rsc\":2},\n  \"2\":{\"suc\":\"4\",\"mod\":(\"A\",\"B\"),\"drt\":[2,3],\"rsc\":[2, 1]},\n  \"3\":{\"suc\":\"5\",\"mod\":(\"A\",\"B\"),\"drt\":[1,2],\"rsc\":[3, 1]},\n  \"4\":{\"suc\":\"5\",\"mod\":\"A\",      \"drt\":2,    \"rsc\":3},\n  \"5\": {\"suc\":\"\",\"mod\":\"A\",      \"drt\":0,    \"rsc\":0 }\n}\nimport json\n\nwith open(\"input.json\", \"r\") as jsonfile: \n    TASKS = json.load(jsonfile)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#use-cases",
    "href": "examples.html#use-cases",
    "title": "Implementation",
    "section": "Use-Cases",
    "text": "Use-Cases\n\nDDFACET\nThe workflow is quite simple, with choice of HPC centers, data centers and network connections. The batch size is large and so are the data volumes. For these reasons, optimal scheduling that takes into account facility availability and reliability, is very important.\n\n\n\n\n\nTBC\nTBC\nTBC\n\n\nNSBAS\nTBC\nTBC\nTBC",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#silly-examples",
    "href": "examples.html#silly-examples",
    "title": "Implementation",
    "section": "Silly Examples",
    "text": "Silly Examples\nIn summary, this book has no content whatsoever.\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\n\n\n\n\n\n\nFigure 2.3: A line plot\n\n\n\n\n\nWe observe in Figure 2.3 that there is a clear trend, up and down.\nTo only have code displayed, but not executed…\n#| label: fig-line-plot\n#| fig-cap: \"A line plot \"\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Background and Setting",
    "section": "",
    "text": "The Exa-AtoW Project\nA wide-scale, cross-facility workflow is a complex beast. It reunites users, jobs, and facilities, each with its resources and constraints. In the workflows that interest us, the facilites include data centres, HPC1 centres, and the network connections between these.\nThe basic problem can be resumed as follows: find an optimal schedule \\(S\\) for a collection of jobs \\(J\\) to be executed on a set of facilities \\(F,\\) subject to constraints on resources, availability, precedences. The optimization can be performed for various objectives, or combinations of these, such as cost, project duration, facility availability, environmental impact. The presence of uncertainty plays a central role and is included in the optimization process.\nExa-AToW focuses on effective end-to-end solutions, at scale, by considering not only functional dimensions such as workflows and data logistics but also resource federation governance, cybersecurity, energy, and sustainability.",
    "crumbs": [
      "Introduction",
      "Background and Setting"
    ]
  },
  {
    "objectID": "intro.html#the-exa-atow-project",
    "href": "intro.html#the-exa-atow-project",
    "title": "Background and Setting",
    "section": "",
    "text": "This work is part of the Exa-AtoW project, a member of the NumPEx consortium. The Exa-AToW project aims at providing solutions for the efficient management of large-scale workflows composed of HPDA, AI, and HPC tasks that are distributed over a continuum of resources ranging from the Exascale, HPC, and Data infrastructures.https://numpex.org",
    "crumbs": [
      "Introduction",
      "Background and Setting"
    ]
  },
  {
    "objectID": "intro.html#continuum-digital-twin-or-shadow",
    "href": "intro.html#continuum-digital-twin-or-shadow",
    "title": "Background and Setting",
    "section": "Continuum Digital Twin or Shadow",
    "text": "Continuum Digital Twin or Shadow\nGiven the inherent complexity of Exascale workflows, they will inevitably be executed on a cross-facility infrastructure. Such a multi-component basis will inevtibaly be subject to uncertainties in availability, maintenance, cost, etc. In addition, the cybersecurity constraints will impose strict access conditions that make workflow testing basically impossible. And, more recently, the issue of sustainability and energy consumption by cyberinfrastructure (IEA 2025) is a critical issue, in particular for so-called hyperscalers and data centers used for AI training and inference.\nFor all these reasons, the presence of a digital twin, or shadow, is indispensable for testing and planning workflow executions before actually executing them. The computer science setup, based on micro-services and ontologies, is fully described in (Garénaux-Gruau, Bodin, and Asch 2026a) and extended use-cases are presented in (Garénaux-Gruau, Bodin, and Asch 2026b).\n\n\n\n\n\n\n\n\ngraph LR\n    A[SIM] --&gt; B[SCD]\n    B --&gt; C[OPT]\n    C --&gt; A\n\n\n\n\n\n\n\n\nFigure 1: Three modules of the CDT: simuulation (SIM), scheduling (SCD), optimization (OPT). An initial workflow definition enters at the left and an optimal workflow is produced.\n\n\n\nThe core of the CDT is a set of three modules: simulation, scheduling and optimization, as shown in Figure 1. They can be used independently, or be chained together. These three are fed by a shared database, based on a common ontology that contains descriptions of all the jobs to perform, resources available, constraints to be respected, and any objectives to be attained. This database is connected to, and communicates with the real world—see Figure 2. This communication can take the form of a MADPP (machine actionable data project plan), a user-interface, or a combination of the two (Garénaux-Gruau, Bodin, and Asch 2026a).\n\n\n\n\n\n\nFigure 2: Global software architecture of the CDT, consisting of three modules: simulation (SIM), scheduling (SCD), optimization (OPT).\n\n\n\nAll details can be found in (Garénaux-Gruau, Bodin, and Asch 2026c).",
    "crumbs": [
      "Introduction",
      "Background and Setting"
    ]
  },
  {
    "objectID": "intro.html#uncertainty",
    "href": "intro.html#uncertainty",
    "title": "Background and Setting",
    "section": "Uncertainty",
    "text": "Uncertainty\nDeterministic schedules optimize for a world that, in theory, never materializes. Processing times vary, machines fail, networks are overloaded, demand shifts. As a result, a schedule that is “optimal” under perfect information often performs poorly when reality intervenes. Stochastic formulations, on the other hand, explicitly hedge against variability. The resulting schedules may sacrifice some of the theoretical efficiency, but maintain feasibility when disruptions occur, thus avoiding costly rescheduling or missed deadlines. Rather than a single makespan or cost figure, one can obtain distributions: “We meet the deadline with 95% confidence” which is far more informative than “the expected completion is Tuesday.”\nHence, when uncertainty in job durations or data transfer arrivals is modeled, the true value of buffer capacity, parallel facilities, or overtime flexibility becomes visible. Deterministic models systematically undervalue these. We can compute the value of the stochastic solution (VSS), which quantifies what can be gained by solving the full stochastic program rather than just optimizing against average conditions. Note that averaging yields a deterministic problem.\nThe Value of Stochastic Solution (VSS) is defined as the difference between the Expectation of the Expected Value Solution (EEVS) and the optimal objective value of the Recourse Problem (RP). The VSS quantifies the benefit of using a stochastic model in place of a deterministic one in decision-making problems under uncertainty. A large VSS signals that the system is sensitive to variability, hedging decisions matter, and the deterministic approximation is potentially dangerous.\n\n\n\\[\\mathrm{VSS} = \\mathrm{EEV} - \\mathrm{RP}\\]\nIn conclusion, when faced with expensive (financially and environmentally), time-consuming Exascale workflows, the need to consider uncertainty in the scheduling program is vital. Stochastic-based scheduling can take into account any uncertain resources and all uncertain costs—a good example would be variable energy costs. The solution thus obtained will permit a hedging strategy. We can, in addition, perform risk analysis, where we compare alternative deployments of the workflow as a function of our risk profile.\n\n\n\n\nGarénaux-Gruau, Marius, François Bodin, and Mark Asch. 2026a. “Continuum Digital Twin Implementation.” https://arxiv.org/abs/26xx.xxxx.\n\n\n———. 2026b. “Continuum Digital Twin Use Cases.” https://arxiv.org/abs/26xx.xxxx.\n\n\n———. 2026c. “Continuum Digital Twin—Mathematical Models.” https://arxiv.org/abs/26xx.xxxx.\n\n\nIEA, Paris. 2025. “Energy and AI.” https://www.iea.org/reports/energy-and-ai.",
    "crumbs": [
      "Introduction",
      "Background and Setting"
    ]
  },
  {
    "objectID": "theory.html",
    "href": "theory.html",
    "title": "Theoretical Framework",
    "section": "",
    "text": "Some History…\nThe development of a framework for CDT process scheduling is rooted in the job scheduling problems that emerged with industrialization and assembly-line work. It is not a coincidence that many of the classical scheduling problems have names like Job Shop Problem or Flow Shop Problem. Back then and now the targets are the same: execute complex jobs that might need treatment on different machines in a defined sequential orders with certain degrees of efficiency. Efficiency in this context can be defined in a number of ways. It might be the total time needed to execute a set of jobs, the compliance of given deadlines, the minimization of overall costs or a combination of all the above.\nThere are two ways to view the the Continuum Digital Twin1:\nThe first is best modelled by a supply chain model. The second is principally a scheduling approach.\nWe propose a combined model for the CDT, composed of a Supply Chain Network Design2 coupled with a Resource Constrained Process Scheduling3. In such a hierarchical system, the supply chain model allocates jobs to the best facilities, and the scheduling model then (optimally) sequences jobs among facilities and within a given facility. Supply chain optimization emphasizes “where” (facility choice, data transfer mode). Scheduling emphasizes “when” and “in what order.”",
    "crumbs": [
      "Theory",
      "Theoretical Framework"
    ]
  },
  {
    "objectID": "theory.html#some-history",
    "href": "theory.html#some-history",
    "title": "Theoretical Framework",
    "section": "",
    "text": "1 CDT\nFacility- or Machine-centered view.\nJob-centered view.\n\n\n\n\n\n\n\n\nFigure 1: Two different viewponts of the CDT: a supply chain model (left) and a scheduling model (right). DC = data center, CC = compute center, J = job.\n\n\n\n\n2 SCND3 RCPSPRecall the basic problem: given a directed graph of \\(N\\) data storage, transfer and processing jobs \\(\\mathscr{J},\\) find an optimal allocation \\(A\\) and a feasible schedule \\(S.\\) Further details below.\\(\\mathscr{J}=\\{ J_1, J_2, \\ldots J_N\\},\\)",
    "crumbs": [
      "Theory",
      "Theoretical Framework"
    ]
  },
  {
    "objectID": "theory.html#supply-chains-with-scheduling",
    "href": "theory.html#supply-chains-with-scheduling",
    "title": "Theoretical Framework",
    "section": "Supply Chains with Scheduling",
    "text": "Supply Chains with Scheduling\nLet us begin by defining supply chains and scheduling in the context of the CDT.\n\nDefinition 1 (Supply Chain) A supply chain is a network (directed graph) of jobs, facilities, data storage, networks, processing and end-product delivery to users. The design poroblem is to optimally allocate an ordered list of data storage and data processing jobs to an optimal choice of storage and processing centres.\n\n\nDefinition 2 (Scheduling) Scheduling is a decision-making process that deals with the allocation of (limited) resources to tasks over given time periods. Its goal is to optimize one or more objectives. The resulting schedule is a job sequence determined for every machine (facility) of the processing system.\n\nThese two models are complementary:\n\nthe SCND can be used for global, over a fixed period, modelling—for example over an entire project duration, or annualized;\nthe RCPSP can be used for time-dependent models, especially when uncertainty is introduced, as in a two-stage, or multi-stage, model—see below Section Uncertainty.\n\nIn Figure 2 and Figure 3 below, we show the two alternative viewpoints of a simple 4-job, 4-machine scheduling problem. The global mathematical formulation will effectively include and combine these two viewpoints, as depicted in Figure 4 and formulated below.\n\n\n\n\n\n\n\n\ngraph LR\n    A[0] --&gt;|\"$$c_{0,1}$$\"| B(\"$$J_1$$\")\n    B --&gt;|\"$$c_{1,2}$$\"| C(\"$$J_2$$\")\n    C --&gt;|\"$$c_{2,3}$$\"| D(\"$$J_3$$\")\n    C --&gt;|\"$$c_{2,4}$$\"| E(\"$$J_4$$\")\n    D --&gt;|\"$$c_{3,5}$$\"| F[5]\n    E --&gt;|\"$$c_{4,5}$$\"| F\n\n\n\n\n\n\n\n\n\nFigure 2: Job-centered view: A simple directed graph (DAG) for a genomics workflow with 4 processing jobs \\(J_1,\\cdots, J_4,\\) and data transfers \\(c_{i,j}\\) between them, including initial upload and final download. The tasks 0 and 5 are dummy tasks, representing the start and the end of the workflow.\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    A[(DC1)]:::otherclass --&gt; C{{HPC1}}:::thirdclass\n    B[(DC2)]:::otherclass \n    A --&gt; D{{HPC2}}:::thirdclass\n    %%A[(data1)]:::someclass --&gt; E{{HPC3}}:::thirdclass\n    C --&gt; F[(DC1)]:::otherclass\n    C --&gt; G[(DC2)]:::otherclass\n    F --&gt; H{{HPC1}}:::thirdclass\n    F --&gt; I{{HPC2}}:::thirdclass  \n    classDef someclass stroke:#f00\n    classDef otherclass stroke:#0f0\n    classDef thirdclass stroke:#00f\n\n\n\n\n\n\n\n\n\nFigure 3: Machine-centered view: Supply chain model for the CDT. For a given job, the dataset (stored in one of two Datacentres, \\(\\mathrm{DC}_1\\) or \\(\\mathrm{DC}_2\\)) can be processed on one of two HPC centres (\\(\\mathrm{HPC}_1\\) or \\(\\mathrm{HPC}_2\\)), and ouput data is sent to (and stored on) one of the two Datacentres, ready as input for the next job. This is repeated for each job in the ordered job list (DAG).\n\n\n\n\n\n\n\n\n\nFigure 4: The CDT model is based on RCPSP and SCND.",
    "crumbs": [
      "Theory",
      "Theoretical Framework"
    ]
  },
  {
    "objectID": "theory.html#supply-chain-network-design-with-resource-constrained-scheduling",
    "href": "theory.html#supply-chain-network-design-with-resource-constrained-scheduling",
    "title": "Theoretical Framework",
    "section": "Supply Chain Network Design with Resource Constrained Scheduling",
    "text": "Supply Chain Network Design with Resource Constrained Scheduling\n\nProblem Definition\nThe resource-constrained project scheduling problem is a classical, well-known problem in operations research, and started with the CPM4 that was developed in the 1950’s. A number of activities are to be scheduled. Each activity has a duration and cannot be interrupted. There are a set of precedence relations between pairs of activities which state that the second activity must start after the first has finished.\n4 Critical Path MethodThe set of precedence relations are usually given as a directed acyclic graph (DAG), where the edge \\((i,j)\\) represents a precedence relation where job \\(i\\) must finish before job \\(j\\) begins. The DAG contains two additional dummy activities with duration 0, the source and sink, where the source is the first activity and the sink is the last activity.\nThere are also sets of renewable resources and non-renewable resources. Each resource has a maximum capacity and at any given time slot no more than this amount can be in use. Each activity has a demand (possibly zero) on each resource. The dummy source and sink activities have zero demand on all resources.\nMulti-Mode Variant The multi-mode resource-constrained project scheduling problem5 is an extension of the resource-constrained project scheduling problem where each task can be executed in one of a number of alternative modes. The problem aims to select a single task mode from a set of available modes in order to construct a precedence- and resource-feasible project schedule with a minimal makespan. This is similar to a supply chain.\n5 MRCPSPNon-Renewable Resources Another extension concerns non-renewable resources. Each non-renewable resource has a capacity for the entire schedule. An example would be a financial, or human resources budget that applies to the entire project. Modes of activities must be chosen to avoid exceeding the total capacity of each of the non-renewable resources.\nTime Windows Instead of optimizing over the maximum value of the project timespan, we can use time windows. The benefit of time windows is twofold: first, they can be used in the mathematical programming formulation to reduce the number of variables substantially, i.e. they provide a tighter formulation. Second, they can be utilized in several enumeration procedures to speed up the convergence of the underlying optimization algorithms.\n\n\nState Variables\nThe state of the system at a given time \\(t,\\) is represented by a set of binary-valued state variables that designate the facilities that are used, at each stage, by each job to be performed in the workflow.\n\n\nObjective Function\nThe overall objective is to combine location decisions—which centres to use—with allocation decisions—how to distribute the workloads and jobs among the chosen centres (data and compute). Various project performance metrics can be optimized, including task-based, resource-based, financial-based and user-based metrics. One can minimize makespan, tardiness, resource consumption, or maximize total NPV with respect to sustainability, for example.\nThere can be a single objective such as minimizing (any function of) the total of fixed and variable costs, or minimizing the completion time (makespan). Multiple objective optimization6 seeks a tradeoff between minimum cost and maximum sustainability (minimum environmental impact). Finally, stochastic optimization takes into account the uncertainties of resource availabilities and delays, maintenance and failures, resource allocations, variable energy costs, project costs (HR, budget).\n6 MOO7 Some terms can be ignored by setting the coefficients to zero, depending on the context.The overall, deterministic cost function can be expressed either as a bottleneck objective, where we seek to minimize the longest or most expensive job, or as a weighted sum over all jobs of makespan, cost and any functions of these.7\nFor example, suppose we have \\(m\\) machines \\(\\{M_j\\}_{j=1}^{m}\\) to process \\(n\\) jobs \\(\\{J_i\\}_{i=1}^{n}.\\) A job \\(J_i\\) can eventually be broken down into \\(n_i\\) operations \\(O_{i1},\\ldots,O_{in_i},\\) each with its own processing requirement \\(p_{ij}.\\)\nObjective Functions Denote the finishing time of job \\(J_i\\) by \\(C_i\\) and the associated cost \\(f_i(C_i).\\) Then there are two types of total cost functions, the bottleneck objective \\[\n   f_{\\mathrm{max}}(C) \\doteq \\max \\{f_i(C_i) \\mid i=1,\\ldots,n\\}\n\\] and the sum objective \\[\n   \\sum f_i(C) \\doteq  \\sum_{i=1}^{n} f_i(C_i).\n\\] The sum can also be weighted, if required.\n\n\nMathematical Formulation - Deterministic Model\nResource-Constrained Project Scheduling Problem (RCPSP)\nThe Resource-Constrained Project Scheduling Problem (RCPSP) is an NP-hard combinatorial optimization problem that consists of finding a feasible scheduling for a set of \\(n\\) jobs subject to resource and precedence constraints. Each job has a processing time, a set of successor jobs and a required amount of different resources. Resources may be scarce but are renewable at each time period. Precedence constraints between jobs mean that no jobs may start before all its predecessors are completed. The jobs must be scheduled non-preemptively, i.e., once started, their processing cannot be interrupted.\nThe RCPSP has the following input data:\n\n\\(\\mathcal{J} = \\{J_1, J_2, \\ldots, J_n \\}\\) set of jobs.\n\\(\\mathcal{R}\\) set of renewable resources.\n\\(\\mathcal{S}\\) set of precedences8 between jobs \\((i,j)\\in\\mathcal{J}\\times\\mathcal{J}.\\)\n\\(\\mathcal{T}\\) planning horizon: set of possible processing times for jobs.\n\\(p_{j}\\) processing time of job \\(j.\\)\n\\(u_{jr}\\) amount of (renewable) resource \\(r\\) required for processing job \\(j.\\)\n\\(c_{r}\\) capacity of renewable resource \\(r.\\)\n\n8 These can be rigorously defined using an order relation, \\(i \\prec j\\).9 An alternative formulation, based on disjunctions will be presenetd in the Examples—see Using PYOMO.There are many different Mixed Integer Linear Programming (MILP) formulations for the RCPSP. We choose the most suitable, discrete-time (DT) formulation9. This is a binary formulation where we have a binary variable \\(x_{i,t}\\) for each activity \\(i\\) and starting time/date \\(t,\\)\n\\[ x_{i,t} = \\begin{cases} 1, \\quad \\text{if activity $i$ starts on day/time $t,$} \\\\ 0, \\quad  \\text{otherwise.}  \\end{cases} \\]\nThe binary programming formulation, proposed by Pritsker et al. in 1986 can be written as follows.\n\\[\n\\begin{align}\n\\text{Minimize} \\quad &  \\sum_{t\\in \\mathcal{T}} t\\cdot x_{n+1,t} & (1)\\\\\n\\text{Subject to:} \\quad &\n\\sum_{t\\in \\mathcal{T}} x_{j,t}  = 1  \\,\\,\\, \\forall j\\in J & (2)\\\\\n& \\sum_{j\\in J} \\sum_{t_2=t-p_{j}+1}^{t} u_{jr}x_{j,t_2}  \\leq c_{r}  \\,\\,\\, \\forall t\\in \\mathcal{T}, r \\in R & (3) \\\\\n& \\sum_{t\\in \\mathcal{T}} t\\cdot x_{s,t} - \\sum_{t \\in \\mathcal{T}} t\\cdot x_{j,t}  \\geq p_{j}  \\,\\,\\, \\forall (j,s) \\in S & (4)\\\\\n& x_{j,t}  \\in \\{0,1\\} \\,\\,\\, \\forall j\\in J, t \\in \\mathcal{T} & (5)\n\\end{align}\\]\nThe objective function (1) represents the sum of all possible start dates for the final sink job (dummy variable) \\(x_{n+1,t}.\\) We know that only one of these variables will equal 1 for a specific \\(t.\\) Therefore, by minimizing the sum of the product \\(t \\cdot x_{n+1,t},\\) we are effectively minimizing the total project duration. Constraint (2) ensures that each activity \\(i\\) has exactly one start date, i.e. a single execution. Constraint (3) guarantees that for any time period \\(t,\\) the schedule does not exceed the capacity \\(R_k\\) for any resource \\(k.\\) Finally, constraint (4) ensures that if an activity \\(j\\) follows another activity \\(i,\\) then activity \\(j\\) must start after the finish time of activity \\(i,\\) which is equal to the start time of activity \\(i\\) plus its duration \\(p_i.\\)\nTime-indexed vs. Disjunctive approaches\nMost common models for the RCPSP rely on time discretization where the scheduling horizon is decomposed into discrete time intervals of unit length. The jobs get allocated to feasible starting times which respect the resource and precedence restrictions. Since the model size expands with increasing scheduling horizon, time-discrete models can become intractable for large time horizons. In this case, we can resort to disjunctive formulations, based on the big-M approach. See examples in the Using PYOMO section.\nMutli-Project Multi-Mode RCPSP\nNote that the above formulation is restricted to temporal scheduling on a single machine, and for a single project—a collection of jobs. This formulation can be generalized to deal with multiple machines and multiple projects. In this case, the formulation becomes very similar to that of a supply chain. It is referred to in the literature as the multi-mode resource-constrained multi-project scheduling problem, or MRCMPSP.\nMulti-Mode The single-mode RCPSP assumed that each activity has only one way to be executed, whereas the multi-mode RCPSP considers multiple ways to execute an activity, which often have tradeoffs in duration, cost, or resource requirement.\nLet the decision variable \\(x_{jm,t} \\in \\{0,1 \\}\\) denote the execution of job \\(j\\) in mode \\(m\\) completed in period \\(t.\\) Then the MRCPSP with tight, time-indexed formulation10 can be written as:\n10 A disjunctive formulation, based on XOR relations, is also possible—see Using PYOMO\\[\n\\begin{align}\n\\min \\quad &  \\sum_{t=\\mathrm{EF}_J}^{\\mathrm{LF}_J} t\\cdot x_{J1,t} & (1)\\\\\n\\text{s.t.} \\quad &\n\\sum_{m=1}^{M_j}  \\sum_{t=\\mathrm{EF}_J}^{\\mathrm{LF}_J} x_{jm,t}  = 1,  \\,\\,\\, j=1,\\ldots, J ,& (2)\\\\\n& \\sum_{m=1}^{M_j} \\sum_{t=\\mathrm{EF}_h}^{\\mathrm{LF}_h} t \\cdot x_{hm,t} \\le \\sum_{m=1}^{M_j}\\sum_{t=\\mathrm{EF}_j}^{\\mathrm{LF}_j} (t - p_{jm}) \\cdot x_{jm,t},  \\,\\,\\, j=2,\\ldots, J, \\, h \\in \\mathcal{P}_j , & (3)\\\\\n& \\sum_{j=2}^{J-1} \\sum_{m=1}^{M_j} k_{jmr}^{\\rho} \\sum_{q=\\max\\{t,\\mathrm{EF}_j\\} }^{\\min \\{ t+p_{jm}-1,\\mathrm{LF}_j \\}}  x_{jm,q} \\le K_r^{\\rho}, \\,\\,\\,  r\\in R^{\\rho}, \\, t=1,\\ldots, \\bar{T}, & (4) \\\\\n& \\sum_{j=2}^{J-1} \\sum_{m=1}^{M_j} k_{jmr}^{\\nu}   \\sum_{t=\\mathrm{EF}_J}^{\\mathrm{LF}_J}  x_{jm,t} \\le K_r^{\\nu}, \\,\\,\\, r\\in R^{\\nu},  & (5)\\\\\n& x_{jm,t}  \\in \\{0,1\\}, \\,\\,\\, j=1,\\ldots,J, \\, m=1,\\ldots ,M_j, \\, t =0,\\ldots, \\bar{T}, & (6)\n\\end{align}\\] where \\(\\mathcal{P}_j\\) is the set of predecessors of job \\(j,\\) the earliest finish and latest finish times of job \\(j\\) are denoted \\(\\mathrm{EF}_j,\\) \\(\\mathrm{LF}_j,\\) an upper bound on the project’s makespan is given by \\(\\bar{T}\\), and we have denoted renewable resources by the index \\(\\rho\\) and non-renewables by \\(\\nu.\\)\nNote that objective (1) is the minimization of the makespan11, the constraints (2) indicate that each activity is assigned exactly one mode and exactly one finish time, (3) ensures that no activity is started until all its predecessors are finished, (4) ensures that the per-period levels of the renewable resources are met, and consumption of the nonrenewable resources is limited to their availabilities by (5). Finally, restricting the summations12 over time to the intervals \\([\\mathrm{EF}_j, \\mathrm{LF}_j]\\) reduces drastically the number of variables and gives better convergence. These time windows can be computed by simple forward and backward recursion loops.\n11 To which we can add any cost function of the duration.12 This produces what is known as a tighter formulation.13 Or terms, if other costs are to be taken into account, e.g. related to sustainabilityMulti-Objective To include infrastructure costs in the objective function, we just add a term13 \\[\\begin{align}\n\\min \\quad &  \\sum_{t=\\mathrm{EF}_J}^{\\mathrm{LF}_J} t\\cdot x_{J1,t}\n                  + \\sum_{j,m} c_{jm} x_{jm} & (1')\\\\\n\\end{align}\\] where \\(c_{jm}\\) is the cost associated with the use of facility \\(m\\) for task \\(j.\\)\nMulti-Project We can also perform simultaneous scheduling of a set of multiple projects taking into account the availability of local and global resources under different time and resource constraints. This has practical importance, at national and European levels, when cross-facility implies exploitation of cyberinfrastructure resources across different countries, for example, as would be the case for EuroHPC14, at the European level, or GENCI15 for France. Imagine being able to plan and pilot multiple exascale projects, on multiple sites, over multiple countries…16\n14  https://www.eurohpc-ju.europa.eu/ 15  https://www.genci.fr// 16 These would be multiple states, in the USA context.17 SCCPConclusion This general formulation of the RCPSP is then mathematically equivalent to the supply chain configuration problem17 with the addition of resource constraints. The loop is closed.",
    "crumbs": [
      "Theory",
      "Theoretical Framework"
    ]
  },
  {
    "objectID": "theory.html#dynamic-networks",
    "href": "theory.html#dynamic-networks",
    "title": "Theoretical Framework",
    "section": "Dynamic Networks",
    "text": "Dynamic Networks\nWe can generalize the supply chain by considering a multi-stage network with an added time dimension. This enables flow and carrying of data and jobs across time periods, in addition to flow among facilities. For example, if certain facilites become unavailable, or less available, as the project evolves over time. This is a kind of recourse, which will be considered below in Section Uncertainty.\n\n\n\n\n\n\n\n\nflowchart LR\n    subgraph t1[\"t = 1\"]\n    direction LR\n    a1((\" \"))--&gt;a2((\" \"))\n    a1--&gt;a3((\" \"))\n    a2--&gt;a4((\" \"))\n    a2-.-&gt;a5((\" \"))\n    end\n    subgraph t2[\"t = 2\"]\n    direction LR\n    b1((\" \"))--&gt;b2((\" \"))\n    b1--&gt;b3((\" \"))\n    b2-.-&gt;b4((\" \"))\n    b2--&gt;b5((\" \"))\n    end\n    t1 --&gt; t2\n    style t1 fill: white\n    style t2 fill: white\n\n\n\n\n\n\n\n\nFigure 5: Multi-stage, dynamic network that evolves over time due to changing availability constraints.",
    "crumbs": [
      "Theory",
      "Theoretical Framework"
    ]
  },
  {
    "objectID": "theory.html#sec-stoch",
    "href": "theory.html#sec-stoch",
    "title": "Theory",
    "section": "Uncertainty",
    "text": "Uncertainty\nIn practice some of the scheduling parameters may be uncertain. The exact duration of an activity, for instance, might not be known at the beginning of the project. Similarly, the number of available resources is another parameter that may not be known before project execution. These uncertainties may be due to different sources, including estimation errors, unforeseen (weather) conditions, late “delivery” (unavailability) of some required resources, unpredictable incidents such as machine breakdown or worker accidents, etc.\n\nStochastic, multistage programming\nBackground\nStochastic programming/optimization (optimal decision-making under uncertainty) is the part of mathematical programming and operations research that studies how to incorporate uncertainty into decision problems. Stochastic programs are primarily about transient decision making.\n\n\n\n\n\n\nImportant\n\n\n\nSome decisions must be made today, but important information will not be available until after the decision is made.\n\n\nAn information stage (normally simply called “stage”) is the most important concept that distinguishes stochastic programming. A stage is a point in time where decisions are made within a model. Stages define the boundaries of time intervals. Stages sometimes follow naturally from the problem setting and sometimes are modeling approximations.\nThe starting point of a stochastic program is the present situation. The model is intended to tell us what to do in light of our goals, constraints, and resources. We then ask what we should do. We are not asking what to do in all possible situations, just what to do based on our present state.\n\nAn inherently two-stage model is a model where the first decision is a major long-term decision, whereas the remaining stages represent the use of this investment. In these cases, mathematically speaking, the first stage will look totally different from the remaining stages, which will all look more or less the same. This is a very important class of models, possibly the most important one for stochastic programming.\nIn inherently multistage models, all stages are of the same type. We face random resource availability, energy prices, unexpected maintenance, etc. We should not confuse information stages with time periods. Stages model the flow of information; time periods represent the ticking of the clock in a model. Stages, on the other hand, are points in time where we make decisions in the model after having learned something new.\n\nFinding a good trade-off between time periods and stages is often crucial when modeling, as it has consequences for model quality, data collection, and solvability of the model.\n\n\n\n\n\n\nCaution\n\n\n\nIn the long run we are all dead. (J.M. Keynes)\n\n\nIn other words, one should not wait too long before taking a decision.\nMathematical Formulation\n\n\n\n\n\n\nFigure 6: A multistage decision process with uncertainty. Uncertain, exogenous inputs \\(\\xi_t\\) arrive, starting from stage \\(t=2,\\) and trigger subsequent recourse actions.\n\n\n\nIn the Figure we depict a generic multistage decision process with state \\(\\mathbf{x}_t\\) that evolves over time, starting at stage \\(t=1,\\) and then receives uncertain, exogenous inputs, \\(\\xi_2, \\xi_3, \\ldots, \\xi_T,\\) at given stages \\(t = 2,3,\\ldots, T.\\) At stage 1, a here-and-now (deterministic) decision is taken. The subsequent sequence of wait-and-see decision functions \\({\\mathbf{x}_t(\\xi_t)}_{t\\in [T]}\\) constitutes a policy, \\(\\pi.\\) The policy thus obtained, provides a decision rule for all stages \\(t \\in [T].\\) The aim of the decision process (stochastic multistage optimization) is then to compute an optimal policy for a given objective and subject to constraints.\nWe will describe in detail the two-stage problem, since the multistage is a straightforward generalisation. In the stochastic setting, we can naturally classify \\(x\\in\\mathscr{X}\\) as the first-stage decision variables, since the initial facilities18 are fixed and \\(y\\in\\mathbb{R}^{\\left|\\mathscr{A}\\right|\\times\\left|\\mathscr{K}\\right|}\\) as the second-stage decision variables, since the job-flow operating conditions are uncertain over time.\n18 Data centers, HPC centers, networks. The two-stage stochastic linear program (Birge and Louveaux 2011), (Shapiro, Dentcheva, and Ruszczyński 2009) is then\n\\[\\begin{align} \\label{eq:2stage}\n\\min_{x\\in\\mathscr{X}} & \\,\\,c^{\\top}x + \\mathrm{E}\\left[Q(x;\\xi)\\right],\n\\end{align}\\] where \\(Q(x;\\xi)\\) is the optimal value of the second-stage problem \\[\\begin{align*}\n\\min_{y\\ge0} & \\,\\,q^{\\top}y\\\\\n\\textrm{s.t.} & \\,\\,Ny=0,\\\\\n& Cy\\ge d,\\\\\n& Sy\\le s,\\\\\n& Ry\\le Mx,\n\\end{align*}\\] where \\(d\\) is the (uncertain) resource demand, \\(s\\) is the (uncertain) resource supply, the random vector \\(\\xi=(q,d,s,R,M)\\) and \\(y=y(\\xi).\\) The expectation is taken with respect to the joint probability distribution function19 of \\(\\xi.\\) In the terminology of state-space, we can consider \\(x\\) as the state variable, and \\(y\\) as the control variable.\n19 Either continuous or discrete, it is derived either from theory or observations, or both.To treat the occurrence of infeasibility, where the first-stage solution does not satisfy the second-stage constraints, e.g. \\(Cy\\nleqslant d,\\) we introduce a recourse action \\(z\\) that supplies the deficit \\(d-Cy\\) at some penalty cost. Then the second-stage problem becomes \\[\\begin{align*}\n\\min_{y\\ge0} & \\,\\,q^{\\top}y+h^{\\top}z\\\\\n\\textrm{s.t.} & \\,\\,Ny=0,\\\\\n& Cy+z\\ge d,\\\\\n& Sy\\le s,\\\\\n& Ry\\le Mx,\n\\end{align*}\\] where \\(h\\) represents the vector of (positive) recourse costs.\nIn the multistage case, we will have a succession of recourse stages, yielding the multistage program (Powell 2022),\n\\[\n    \\min_{\\pi \\in \\Pi} \\mathrm{E} \\left[ \\sum^{T}_{t=1} \\gamma^{t-1} f_t(x_t;\\xi_t) \\right],\n\\] subject to \\[\n     x_t \\in \\mathcal{X}_t(x_{t-1};\\xi_{t-1}), \\quad t=1 \\ldots, T,\n\\] where \\(\\pi\\) is a policy, \\(\\gamma\\) is a discount factor, \\(f_t\\) is a cost function, \\(x_t\\) is a decision and \\(\\mathcal{X}_t\\) are the constraints. A policy is, by definition, a method that optimizes the objective. For example, in Google maps, the policy is to decide whether to turn left or right by optimizing over the time required to transverse the next link in the network plus the remaining time to get to the destination.\nNote that there are various forms of minimization in stochastic scheduling. Whenever an objective function has to be minimized, it has to be specified in what sense the objective has to be minimized.\n\nExpectation sense is the crudest form of optimization, e.g., one wishes to minimize (a function of) the expected makespan, that is \\(\\mathrm{E}\\left[f\\left(C_{\\mathrm{max}}\\right)\\right],\\) and find a policy under which the expected makespan is smaller than the expected makespan under any other policy.\nStochastic sense is a stronger form of optimization. If a schedule or policy minimizes \\(f\\left(C_{\\mathrm{max}}\\right)\\) stochastically, then the makespan under the optimal schedule or policy is stochastically (in probability, or in law) less than the makespan under any other schedule or policy.\n\n\n\n\n\nBirge, John R., and François Louveaux. 2011. Introduction to Stochastic Programming. Second edition. Springer New York, NY. https://doi.org/10.1007/978-1-4614-0237-4.\n\n\nPowell, Warren B. 2022. Reinforcement Learning and Stochastic Optimization: A Unified Framework for Sequential Decisions. John Wiley & Sons.\n\n\nShapiro, Alexander, Darinka Dentcheva, and Andrzej Ruszczyński. 2009. Lectures on Stochastic Programming. SIAM, Society for Industrial; Applied Mathematics. https://doi.org/10.1137/1.9780898718751.",
    "crumbs": [
      "Theory",
      "Theory"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Optimal Scheduling for Cross-Facility Workflows",
    "section": "",
    "text": "Welcome\nThis (online) user-guide contains a complete presentation of optimal scheduling applied to Exascale and post-Exascale workflows. These workflows combine data acquisition, data storage, data transfer and data analysis. The HPC components of such workflows can incorporate a diverse range of models, including partial differential equation solvers, algebraic solvers, AI/ML-based models, and data analytics components, all integrated into a single process (Ferreira da Silva et al. 2024), (Unat et al. 2025).\nThe objective here is to address the inherent cross-facility, multi-domain character of these workflows. This requires a very carefully-crafted theoretical foundation that can be readily generalized and extended to these contexts. The material covers both the theory and its application to practical use-cases, including real contexts with uncertainties emanating from different causes. To understand these well, numerous examples are provided in the form of python code snippets and jupyter notebooks. All of these are intgerated in a digital twin1 of the underlying cyberinfrastructure, the so-called digital continuum.\nThe Continuum Digital Twin (CDT) is defined and described in the series of forthcoming papers (Garénaux-Gruau, Martineau, et al. 2026; Garénaux-Gruau, Certenais, et al. 2026; Garénaux-Gruau, Bodin, and Asch 2026). For optimization and scheduling, there are numerous excellent references. Among these we point out particularly (Birge and Louveaux 2011), (Pinedo 2022), and (Powell 2022). Most of the codes are based on the wonderful pyomo framework (Bynum et al. 2021), (Hart, Watson, and Woodruff 2011) and (Postek et al. 2025). General background on exascale workflows can be found in (M. Asch et al. 2018).",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#author",
    "href": "index.html#author",
    "title": "Optimal Scheduling for Cross-Facility Workflows",
    "section": "Author",
    "text": "Author\nMark Asch is Emeritus Professor of the Université de Picardie Jules Verne, Mathematics department.\n https://markasch.github.io/DT-tbx-v1/\n https://github.com/markasch/\n http://masch.perso.math.cnrs.fr/\n mark.asch@u-picardie.fr",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#citation",
    "href": "index.html#citation",
    "title": "Optimal Scheduling for Cross-Facility Workflows",
    "section": "Citation",
    "text": "Citation\nAsch, Mark. Optimal Scheduling for Cross-Facility Workflows. Online (2026) https://markasch.github.io/RCP4CDT/\n@book{Asch2026\n    title = {Optimal {S}cheduling for {C}ross-{F}acility {W}orkflows},\n    author = {Asch, Mark},\n    url = {https://markasch.github.io/RCP4CDT/},\n    year = {2026},\n    publisher = {Online}\n}",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Optimal Scheduling for Cross-Facility Workflows",
    "section": "License",
    "text": "License\nThis online book is frequently updated and edited. It’s content is free to use, licensed under a Creative Commons licence, and the code can be found on GitHub. A physical copy of the book will be available at a later date.\nLicense: Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Optimal Scheduling for Cross-Facility Workflows",
    "section": "References",
    "text": "References\n\n\nAsch, Mark. 2022. A Toolbox for Digital\nTwins: From\nModel-Based to\nData-Driven. Philadelphia, PA: Society\nfor Industrial; Applied Mathematics. https://doi.org/10.1137/1.9781611976977.\n\n\nAsch, M, T Moore, R Badia, M Beck, P Beckman, T Bidot, F Bodin, et al.\n2018. “Big Data and Extreme-Scale Computing: Pathways to\nConvergence-Toward a Shaping Strategy for a Future Software and Data\nEcosystem for Scientific Inquiry.” The International Journal\nof High Performance Computing Applications 32 (4): 435–79. https://doi.org/10.1177/1094342018778123.\n\n\nBirge, John R., and François Louveaux. 2011. Introduction to\nStochastic Programming. Second edition. Springer New\nYork, NY. https://doi.org/10.1007/978-1-4614-0237-4.\n\n\nBynum, Michael L., Gabriel A. Hackebeil, William E. Hart, Carl D. Laird,\nBethany L. Nicholson, John D. Siirola, Jean-Paul Watson, and David L.\nWoodruff. 2021. Pyomo–Optimization Modeling in Python. Third.\nVol. 67. Springer Science & Business Media.\n\n\nFerreira da Silva, Rafael, Rosa M. Badia, Deborah Bard, Ian T. Foster,\nShantenu Jha, and Frederic Suter. 2024.“Frontiers in Scientific Workflows: Pervasive Integration\nWith High-Performance Computing .” Computer 57\n(08): 36–44. https://doi.org/10.1109/MC.2024.3401542.\n\n\nGarénaux-Gruau, Marius, François Bodin, and Mark Asch. 2026.\n“Continuum Digital Twin—Mathematical Models.” https://arxiv.org/abs/26xx.xxxx.\n\n\nGarénaux-Gruau, Marius, Mathis Certenais, Laurent Morin, François Bodin,\nand Mark Asch. 2026. “Continuum Digital Twin Use Cases.” https://arxiv.org/abs/26xx.xxxx.\n\n\nGarénaux-Gruau, Marius, Olivier Martineau, François Bodin, and Mark\nAsch. 2026. “Continuum Digital Twin Implementation.” https://arxiv.org/abs/26xx.xxxx.\n\n\nHart, William E, Jean-Paul Watson, and David L Woodruff. 2011.\n“Pyomo: Modeling and Solving Mathematical Programs in\nPython.” Mathematical Programming Computation 3 (3):\n219–60.\n\n\nIEA, Paris. 2025. “Energy and AI.” https://www.iea.org/reports/energy-and-ai.\n\n\nPinedo, Michael L. 2022. Scheduling: Theory, Algorithms, and\nSystems. 6th edition. Springer Cham.\n\n\nPostek, Krzysztof, Alessandro Zocca, Joaquim Gromicho, and Jeffrey\nKantor. 2025. Hands-On Mathematical\nOptimization with Python. Cambridge University Press. https://doi.org/10.1017/9781009493512.\n\n\nPowell, Warren B. 2022. Reinforcement Learning and Stochastic\nOptimization: A Unified Framework for Sequential Decisions. John\nWiley & Sons.\n\n\nShapiro, Alexander, Darinka Dentcheva, and Andrzej Ruszczyński. 2009.\nLectures on Stochastic Programming.\nSIAM, Society for Industrial; Applied Mathematics. https://doi.org/10.1137/1.9780898718751.\n\n\nUnat, Didem, Anshu Dubey, Emmanuel Jeannot, and John Shalf. 2025.\n“The Persistent Challenge of Data Locality in the Post-Exascale\nEra.” Computing in Science & Engineering 27 (4):\n19–27. https://doi.org/10.1109/MCSE.2025.3567586.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "examples.html#data-model-overview",
    "href": "examples.html#data-model-overview",
    "title": "Implementation",
    "section": "Data Model Overview",
    "text": "Data Model Overview\nThe input consists of four entities:\n\n\n\n\n\n\n\nEntity\nDescription\n\n\n\n\nResources\nAvailable resources with capacities (renewable per period, non-renewable)\n\n\nJobs\nUnits of work to be scheduled\n\n\nModes\nAlternative execution options for each job\n\n\nPrecedences\nDirected edges defining the execution order (DAG)\n\n\n\n\n1. Resources\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\nresource_id\nstring\nyes\nUnique identifier for the resource\n\n\nname\nstring\nno\nHuman-readable name\n\n\ncapacity\ninteger ≥ 0\nyes\nMaximum units available per time period5\n\n\n\n5 For renewable resources. If resource is non-renewable, this is the total available.\n\n2. Jobs\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\njob_id\nstring\nyes\nUnique identifier for the job\n\n\nname\nstring\nno\nHuman-readable name\n\n\nrelease_time\ninteger ≥ 0\nno\nEarliest start time (default: 0)\n\n\ndeadline\ninteger ≥ 0\nno\nLatest finish time (default: none)\n\n\n\n\n\n3. Modes\nEach job must have at least one mode. A mode specifies how a job can be executed.\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\nmode_id\nstring\nyes\nUnique identifier for the mode\n\n\njob_id\nstring\nyes\nReference to parent job\n\n\nduration\ninteger ≥ 0\nyes\nProcessing time in periods\n\n\ncost\nfloat ≥ 0\nyes\nCost of selecting this mode\n\n\nresource_requirements\nlist\nyes\nResources consumed during execution\n\n\n\n\nResource Requirement (nested within Mode)\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\nresource_id\nstring\nyes\nReference to a defined resource\n\n\ndemand\ninteger ≥ 0\nyes\nUnits required per period while job executes\n\n\n\n\n\n\n4. Precedences\nDefines the DAG structure. Each entry represents a directed edge.\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\npredecessor\nstring\nyes\njob_id of the job that must finish first\n\n\nsuccessor\nstring\nyes\njob_id of the job that must start after\n\n\nlag\ninteger ≥ 0\nno\nMinimum time gap between finish and start (default: 0)\n\n\n\nThis gives the following json format.\n\n\nShow Input File Code\n\n{\n  \"problem_name\": \"string (optional)\",\n  \"horizon\": \"integer (optional, planning horizon)\",\n  \n  \"resources\": [\n    {\n      \"resource_id\": \"string\",\n      \"name\": \"string (optional)\",\n      \"capacity\": \"integer\"\n    }\n  ],\n  \n  \"jobs\": [\n    {\n      \"job_id\": \"string\",\n      \"name\": \"string (optional)\",\n      \"release_time\": \"integer (optional, default 0)\",\n      \"deadline\": \"integer (optional, default null)\"\n    }\n  ],\n  \n  \"modes\": [\n    {\n      \"mode_id\": \"string\",\n      \"job_id\": \"string\",\n      \"duration\": \"integer\",\n      \"cost\": \"number\",\n      \"resource_requirements\": [\n        {\n          \"resource_id\": \"string\",\n          \"demand\": \"integer\"\n        }\n      ]\n    }\n  ],\n  \n  \"precedences\": [\n    {\n      \"predecessor\": \"string (job_id)\",\n      \"successor\": \"string (job_id)\",\n      \"lag\": \"integer (optional, default 0)\"\n    }\n  ]\n}\n\nValidation\nWe provide a JSON schema that the user can use for formal validation of their input files as follows.\nimport json\nimport jsonschema\nfrom jsonschema import validate\nimport DraftValidator\n\n# Load schema and data\nwith open(\"workflow-schema.json\") as f:\n    schema = json.load(f)\n\nwith open(\"my-problem.json\") as f:\n    data = json.load(f)\n\n# Validate\ntry:\n    validate(instance=data, schema=schema)\n    print(\"Input is valid.\")\nexcept jsonschema.ValidationError as e:\n    print(f\"Validation error: {e.message}\")\n    print(f\"Path: {list(e.absolute_path)}\")",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#tabular-definitions",
    "href": "examples.html#tabular-definitions",
    "title": "Implementation",
    "section": "Tabular Definitions",
    "text": "Tabular Definitions\n\n1. Resources\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\nresource_id\nstring\nyes\nUnique identifier for the resource\n\n\nname\nstring\nno\nHuman-readable name\n\n\ncapacity\ninteger ≥ 0\nyes\nMaximum units available per time period\n\n\n\n\n\n2. Jobs\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\njob_id\nstring\nyes\nUnique identifier for the job\n\n\nname\nstring\nno\nHuman-readable name\n\n\nrelease_time\ninteger ≥ 0\nno\nEarliest start time (default: 0)\n\n\ndeadline\ninteger ≥ 0\nno\nLatest finish time (default: none)\n\n\n\n\n\n3. Modes\nEach job must have at least one mode. A mode specifies how a job can be executed.\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\nmode_id\nstring\nyes\nUnique identifier for the mode\n\n\njob_id\nstring\nyes\nReference to parent job\n\n\nduration\ninteger ≥ 0\nyes\nProcessing time in periods\n\n\ncost\nfloat ≥ 0\nyes\nCost of selecting this mode\n\n\nresource_requirements\nlist\nyes\nResources consumed during execution\n\n\n\n\nResource Requirement (nested within Mode)\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\nresource_id\nstring\nyes\nReference to a defined resource\n\n\ndemand\ninteger ≥ 0\nyes\nUnits required per period while job executes\n\n\n\n\n\n\n4. Precedences\nDefines the DAG structure. Each entry represents a directed edge.\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\npredecessor\nstring\nyes\njob_id of the job that must finish first\n\n\nsuccessor\nstring\nyes\njob_id of the job that must start after\n\n\nlag\ninteger ≥ 0\nno\nMinimum time gap between finish and start (default: 0)\n\n\n\n\n\n\nModel Function\nAll the above are necessary and sufficient for the mathematical formulation presented in the section Mathematical Formulation - Deterministic Model. We define a pyomo function that takes a dictionary of tasks as input6, and returns a pyomo model.\n6 See below for examples.# Model function generator\ndef MRCPSP_model(TASKS):\n    model = pyo.ConcreteModel()\n    # tasks is a two dimensional set of (j,m) constructed from the dictionary keys\n    model.TASKS = pyo.Set(initialize=TASKS.keys(), dimen=2)\n    # the set of jobs is constructed from a python set\n    model.JOBS = pyo.Set(initialize=list(set([j for (j, m) in model.TASKS])))\n    # set of machines is constructed from a python set\n    model.MACHINES = pyo.Set(initialize=list(set([m for (j, m) in model.TASKS])))\n    # the order of tasks is constructed as a cross-product of tasks and filtering\n    model.TASKORDER = pyo.Set(\n        initialize = model.TASKS * model.TASKS,\n        dimen      = 4,\n        filter     = lambda model, j, m, k, n: (k, n) == TASKS[(j, m)][\"prec\"],\n    )\n    # the set of disjunctions is cross-product of jobs, jobs, and machines\n    model.DISJUNCTIONS = pyo.Set(\n        initialize = model.JOBS * model.JOBS * model.MACHINES,\n        dimen      = 3,\n        filter     = lambda model, j, k, m: j &lt; k\n                     and (j, m) in model.TASKS\n                     and (k, m) in model.TASKS,\n    )\n    # load duration data into a model parameter for later access\n    @model.Param(model.TASKS)\n    def dur(model, j, m):\n        return TASKS[(j, m)][\"dur\"]\n    # establish an upper bound on makespan\n    ub = sum([model.dur[j, m] for (j, m) in model.TASKS])\n    # create decision variables\n    model.makespan = pyo.Var(bounds=(0, ub))\n    model.start = pyo.Var(model.TASKS, bounds=(0, ub))\n    \n    @model.Objective(sense=pyo.minimize)\n    def minimize_makespan(model):\n        return model.makespan\n    \n    @model.Constraint(model.TASKS)\n    def finish_tasks(model, j, m):\n        return model.start[j, m] + model.dur[j, m] &lt;= model.makespan\n\n    @model.Constraint(model.TASKORDER)\n    def preceding(model, j, m, k, n):\n        return model.start[k, n] + model.dur[k, n] &lt;= model.start[j, m]\n\n    @model.Disjunction(model.DISJUNCTIONS)\n    def no_overlap(model, j, k, m):\n        return [\n            model.start[j, m] + model.dur[j, m] &lt;= model.start[k, m],\n            model.start[k, m] + model.dur[k, m] &lt;= model.start[j, m],\n        ]\n\n    pyo.TransformationFactory(\"gdp.bigm\").apply_to(model)\n    return model\n# Generate the model\nMRCPSP_model(TASKS)\n\n\nOptimization\nThe optimization can be performed by calling one of the built-in solvers of pyomo, or by using one of the more efficient commercial7 solvers, from CPLEX or gurobi.\n7 Free academic versions are available.# model optimization\ndef MRCPSP_solve(model):\n    SOLVER.solve(model)\n    results = [\n        {\n            \"Job\": j,\n            \"Machine\": m,\n            \"Start\": model.start[j, m](),\n            \"Duration\": model.dur[j, m],\n            \"Finish\": model.start[(j, m)]() + model.dur[j, m],\n        }\n        for j, m in model.TASKS\n    ]\n    return results\n# Solve the optimization problem\nresults = MRCPSP_solve(MRCPSP_model(TASKS))\n\n\nOutput\nFinally, we extract the schedule from the results, store them in a suitable dataframe, and output a CSV file with start and finish times of each job, as well as the optimal mode selected for each job. This can also be output in the form of a GANTT chart. Other outputs can include resource usage, energy consumption, machine utilization statistics and costs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#basic-pyomo-linear-programming-example",
    "href": "examples.html#basic-pyomo-linear-programming-example",
    "title": "Implementation",
    "section": "",
    "text": "pyomo.environ provides the framework for building the model\nSolverFactory allows to call the solver used to solve the optimization problem\n\n\n\n\nthe complete model;\na full trace of the optimization process.",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#disjunctions",
    "href": "examples.html#disjunctions",
    "title": "Implementation",
    "section": "Disjunctions",
    "text": "Disjunctions\nThe decisions encountered in the CDT involve discrete, Boolean choices. These can take the following forms:\n\nSequencing decisions, where \\(A\\) ends before \\(B,\\) or \\(B\\) ends before \\(A.\\)\nSwitching decisions, where a facility is used or not.\nAlternative selection among a set of pricing policies, for example for alternative energy sources.\n\nThe general disjunctive problem is formulated as\n\\[\n\\begin{align}\n\\min \\quad &  z=f(x) + \\sum_{k \\in K} c_k & \\text{objective}\\\\\n\\text{s.t.} \\quad &   r(x) \\le 0 & \\text{global constraint} \\\\\n                  &  \\underset{j\\in J_{k}}{\\vee}\\left[\\begin{array}{c}\n                          Y_{jk}\\\\\n                          g_{jk}(x)\\le 0\\\\\n                          c_{k}=\\gamma_{jk}\n                             \\end{array}\\right]  & \\text{disjunctions} \\\\\n                  & \\underset{j\\in J_{k}}{\\veebar} Y_{jk} & \\text{disjunctions} \\\\\n                  & 0\\le x \\le U, \\; c_k \\in \\mathbb{R}, \\;  Y_{jk} = \\{\\text{True, False}\\}\n\\end{align}\\] If the Boolean variable is True both the inequalities and the cost equation are enforced; if the Boolean variable is False they are both ignored.\nFor sequencing decisions, between two tasks \\(i\\) and \\(j,\\) the disjuction is written as \\[\n\\left[\\begin{array}{c}\n            Y_{k}\\\\\n            s_i + d_i \\le s_j\\\\\n\\end{array}\\right] \\vee\n\\left[\\begin{array}{c}\n            \\neg Y_{k}\\\\\n            s_j + d_j \\le s_i\\\\\n\\end{array}\\right] ,\n\\] where \\(s_i,\\) \\(d_i\\) are the start and duration of task \\(i.\\)\nThe pyomo code for the disjunction is written as,\n@model.Disjunction(model.I, model.J) \ndef SequenceIJ(m, i, j):\n    return [ m.start[i] + duration[i] &lt;= m.start[j], \n             m.start[j] + duration[j] &lt;= m.start[i] ]\nWhen faced with such a choice among exclusive options, to convert the problem to a MILP formulation we resort to disjunctive programming based on:\n\nBig-M formulation.\nConvex hull formulation.\n\nConsider the disjunction \\(A \\veebar B \\veebar C,\\) as depicted below. The two possible formulations are:\n\n\n\n\n\n\n\nBig-M\nConvex Hull\n\n\n\n\n\n\n\n\n\nLooser relaxation\nSmaller problems\n\n\nTighter relaxation\nBigger problems\n\n\n\n\nThe respective code lines in the pyomo generalized disjunctive programming gdp module, are\n# Big-M\nTransformationFactory('gdp.bigm')\n# Convex Hull\nTransformationFactory('gdp.chull')\n\n\n\n\n\n\nCaution\n\n\n\nThe disjunctive formulations will always increase the number of variables and constraints of the optimization problem. Thus, they are usually only profitable for long time horizon problems.",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#time-windows---ef-lf-etc.",
    "href": "examples.html#time-windows---ef-lf-etc.",
    "title": "Implementation",
    "section": "Time-Windows - EF, LF, etc.",
    "text": "Time-Windows - EF, LF, etc.\nTo reduce the number of variables in the MILP optimization, we define subsets of the time variable. Recall: the timespan \\([0,T]\\) is discretized into \\(T\\) time periods of length one. Period \\(t\\) refers to the time slot/interval \\([t-1,t],\\) where \\(t=1, \\ldots, T.\\) The processing time (duration) of job \\(j\\) is denoted \\(d_j,\\) the set of immediate predecessor activities of activity \\(j\\) is denoted \\(\\mathcal{P}_j\\) and the set of immediate successor activities of activity \\(j\\) is denoted \\(\\mathcal{S}_j.\\)\nThe forward pass to compute earliest start and finishing times is defined as follows:\nEST[0], EFT[0] = 0 # initialization\nfor j in range(2, n):\n  EST[j] = max(EFT[i] for i in P[j])\n  EFT[j] = EST[j] + d[j]\nThe backward pass to compute latest start and finishing times is defined as follows:\nLFT[0], LST[0] = T # initialization\nfor j in range(n-1, 1, -1):\n  LFT[j] = min(LST[i] for i in S[j])\n  LST[j] = LFT[j] - d[j]",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#model-function",
    "href": "examples.html#model-function",
    "title": "Implementation",
    "section": "Model Function",
    "text": "Model Function\nAll the above are necessary and sufficient for the mathematical formulation presented in the section Mathematical Formulation - Deterministic Model. We define a pyomo function that takes a dictionary of tasks as input6, and returns a pyomo model.\n6 See below for examples.# Model function generator\ndef MRCPSP_model(TASKS):\n    model = pyo.ConcreteModel()\n    # tasks is a two dimensional set of (j,m) constructed from the dictionary keys\n    model.TASKS = pyo.Set(initialize=TASKS.keys(), dimen=2)\n    # the set of jobs is constructed from a python set\n    model.JOBS = pyo.Set(initialize=list(set([j for (j, m) in model.TASKS])))\n    # set of machines is constructed from a python set\n    model.MACHINES = pyo.Set(initialize=list(set([m for (j, m) in model.TASKS])))\n    # the order of tasks is constructed as a cross-product of tasks and filtering\n    model.TASKORDER = pyo.Set(\n        initialize = model.TASKS * model.TASKS,\n        dimen      = 4,\n        filter     = lambda model, j, m, k, n: (k, n) == TASKS[(j, m)][\"prec\"],\n    )\n    # the set of disjunctions is cross-product of jobs, jobs, and machines\n    model.DISJUNCTIONS = pyo.Set(\n        initialize = model.JOBS * model.JOBS * model.MACHINES,\n        dimen      = 3,\n        filter     = lambda model, j, k, m: j &lt; k\n                     and (j, m) in model.TASKS\n                     and (k, m) in model.TASKS,\n    )\n    # load duration data into a model parameter for later access\n    @model.Param(model.TASKS)\n    def dur(model, j, m):\n        return TASKS[(j, m)][\"dur\"]\n    # establish an upper bound on makespan\n    ub = sum([model.dur[j, m] for (j, m) in model.TASKS])\n    # create decision variables\n    model.makespan = pyo.Var(bounds=(0, ub))\n    model.start = pyo.Var(model.TASKS, bounds=(0, ub))\n    \n    @model.Objective(sense=pyo.minimize)\n    def minimize_makespan(model):\n        return model.makespan\n    \n    @model.Constraint(model.TASKS)\n    def finish_tasks(model, j, m):\n        return model.start[j, m] + model.dur[j, m] &lt;= model.makespan\n\n    @model.Constraint(model.TASKORDER)\n    def preceding(model, j, m, k, n):\n        return model.start[k, n] + model.dur[k, n] &lt;= model.start[j, m]\n\n    @model.Disjunction(model.DISJUNCTIONS)\n    def no_overlap(model, j, k, m):\n        return [\n            model.start[j, m] + model.dur[j, m] &lt;= model.start[k, m],\n            model.start[k, m] + model.dur[k, m] &lt;= model.start[j, m],\n        ]\n\n    pyo.TransformationFactory(\"gdp.bigm\").apply_to(model)\n    return model\n# Generate the model\nMRCPSP_model(TASKS)",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#optimization",
    "href": "examples.html#optimization",
    "title": "Implementation",
    "section": "Optimization",
    "text": "Optimization\nThe optimization can be performed by calling one of the built-in solvers of pyomo, or by using one of the more efficient commercial7 solvers, from CPLEX or gurobi.\n7 Free academic versions are available.# model optimization\ndef MRCPSP_solve(model):\n    SOLVER.solve(model)\n    results = [\n        {\n            \"Job\": j,\n            \"Machine\": m,\n            \"Start\": model.start[j, m](),\n            \"Duration\": model.dur[j, m],\n            \"Finish\": model.start[(j, m)]() + model.dur[j, m],\n        }\n        for j, m in model.TASKS\n    ]\n    return results\n# select a suitable solver\nsolver = 'appsi_highs' #'gurobi' 'glpk','cbc','cplex'\nSOLVER = pyo.SolverFactory(solver)\nassert SOLVER.available(), f\"Solver {solver} is not available.\"\n# Solve the optimization problem\nresults = MRCPSP_solve(MRCPSP_model(TASKS))",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#output",
    "href": "examples.html#output",
    "title": "Implementation",
    "section": "Output",
    "text": "Output\nFinally, we extract the schedule from the results, store them in a suitable dataframe, and output a CSV file with start and finish times of each job, as well as the optimal mode selected for each job. This can also be output in the form of a GANTT chart. Other outputs can include resource usage, energy consumption, machine utilization statistics and costs.",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples.html#examples",
    "href": "examples.html#examples",
    "title": "Implementation",
    "section": "Examples",
    "text": "Examples\n\nSimplified Supply Chain Example\nPutting together:\n\nprecedence\nTBC\n\n\n\nSimplified RCPSP Example\nPutting together:\n\nprecedence\ntime-indexed\ndisjunctive\n\n\n\nSimplified MRCPSP Example\nIn this example we have 4 jobs, 2 possible modes, 1 renewable resource and no non-renewable resources. Jobs 2 and 3 can be executed in mode 1 or in mode 2.\n\n\n\n\n\n\n\n\ngraph LR\n    A[\"$$J_0$$\"] --&gt; B(\"$$J_1$$\")\n    A --&gt; C(\"$$J_2$$\")\n    B --&gt; D(\"$$J_3$$\")\n    C --&gt; E(\"$$J_4$$\")\n    D --&gt; F[\"$$J_5$$\"]\n    E --&gt; F\n\n\n\n\n\n\n\n\n\nFigure 2.2: A project network represented as a directed acyclic graph (DAG) for a workflow with 4 processing jobs \\(J_1,\\cdots, J_4.\\) The tasks 0 and 5 are dummy tasks, representing the start and the end of the workflow.\n\n\n\nThe project instance, shown above, is detailed in Table 1, where \\(S_j\\) is the successor list of job \\(j,\\) \\(m\\) is the mode, \\(d_{jm}\\) is the job duration, \\(k^{\\rho}_{jm1}\\) is the renewable resource requirement, \\(R^{\\rho}\\) is the renewable resource list, \\(K^{\\rho}\\) is the renewable resource limit, and \\(R^{\\nu}\\) is the non-renewable resource list, taken as empty. In other words we have 4 jobs, 2 possible modes, 1 renewable resource and no non-renewable resources. Jobs 2 and 3 can be executed in mode 1 or in mode 2.\n\\[\\begin{aligned}\n& \\text {Table 1. Multi-mode RCPSP for a 4-job, 2-mode workflow. }\\\\\n&\\begin{array}{cccccccc}\n%\\begin{tabular}{|c|c|c|c|c|c|c|c|}\n\\hline\nj & S_{j}& m & d_{jm} & k^{\\rho}_{jm1} & R^{\\rho} & K^{\\rho}_{1} & R^{\\nu}\\\\\n\\hline\n0 & \\left\\{ 1,2\\right\\}  & 1 & 0 & 0 & \\left\\{ 1\\right\\}  & 3 & \\emptyset \\\\\n1 & \\left\\{ 3\\right\\}  & 1 & 2 & 2  &  &  & \\\\\n2 & \\left\\{ 4\\right\\}  & 1 & 2 & 2 &  &  & \\\\\n&  & 2 & 3 & 1 &  &  & \\\\\n3 & \\left\\{ 5\\right\\}  & 1 & 1 & 3 &  &  & \\\\\n&  & 2 & 2 & 1 &  &  & \\\\\n4 & \\left\\{ 5\\right\\}  & 1 & 2 & 3 &  &  & \\\\\n5 & \\emptyset & 1 & 0 & 0 &  &  & \\\\\n\\hline\n%\\end{tabular}\n\\end{array}\n\\end{aligned}\\]\nInput File\nThe simplest input file is a direct transcription of the table of variables.\n{\n  \"0\":{\"suc\":(\"1\",\"2\"),\"mod\":\"A\",\"drt\":0,    \"rsc\":0},\n  \"1\":{\"suc\":\"3\",\"mod\":\"A\",      \"drt\":2,    \"rsc\":2},\n  \"2\":{\"suc\":\"4\",\"mod\":(\"A\",\"B\"),\"drt\":[2,3],\"rsc\":[2, 1]},\n  \"3\":{\"suc\":\"5\",\"mod\":(\"A\",\"B\"),\"drt\":[1,2],\"rsc\":[3, 1]},\n  \"4\":{\"suc\":\"5\",\"mod\":\"A\",      \"drt\":2,    \"rsc\":3},\n  \"5\": {\"suc\":\"\",\"mod\":\"A\",      \"drt\":0,    \"rsc\":0 }\n}\nimport json\n\nwith open(\"input.json\", \"r\") as jsonfile: \n    TASKS = json.load(jsonfile)\nThough, for interoperability, we should privilege the data model format, described before.",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Implementation</span>"
    ]
  },
  {
    "objectID": "examples/disjunct-BigM.html",
    "href": "examples/disjunct-BigM.html",
    "title": "Example 1: Disjunction - Big-M formulation",
    "section": "",
    "text": "Explanations will be added soon…\n\nfrom pyomo.environ import *\n\nmodel = ConcreteModel()\n\n# Parameters\nmodel.C_ch = Param(within=NonNegativeReals, default=10)\nmodel.C_m = Param(domain=NonNegativeReals, default=15)\nmodel.Prod_ch = Param(domain=NonNegativeReals, default=2)\nmodel.Prod_m = Param(domain=NonNegativeReals, default=3)\nmodel.CAP = Param(domain=NonNegativeIntegers, default=100)\nmodel.O_min = Param(domain=NonNegativeIntegers, default=10)\nmodel.D_l = Param(domain=NonNegativeReals, default=20)\nmodel.D_c = Param(domain=NonNegativeReals, default=30)\n\n# GDP parameters\nmodel.Cextra = Param(within=NonNegativeReals, default=200)\nmodel.limit_cap = Param(within=NonNegativeIntegers, default=20)\n\n# Variables\nmodel.X = Var(domain=NonNegativeIntegers)\nmodel.Y = Var(domain=NonNegativeIntegers)\n\n# Constraints\nmodel.res1 = Constraint(expr=model.X + model.Y &gt;= model.O_min)\nmodel.res2 = Constraint(expr=model.Y &gt;= 2*model.X)\nmodel.res3 = Constraint(expr=model.X + model.Y &lt;= model.CAP)\nmodel.res4 = Constraint(expr=model.Prod_ch * model.X &gt;= model.D_l)\nmodel.res5 = Constraint(expr=model.Prod_m * model.Y &gt;= model.D_c)\n\n# Conditional cost\nM = 1000\nmodel.Z = Var(domain=Binary)\nmodel.extra_cost1 = Constraint(expr=model.X + model.Y &gt;= model.limit_cap - M * (1 - model.Z))\n# You can try disabling this constraint: since Z is in the objective function this condition is not necessary\nmodel.extra_cost2 = Constraint(expr=model.X + model.Y - model.Z * M &lt;= model.limit_cap)\n\n# Objective\nmodel.obj = Objective(expr=model.C_ch * model.X + model.C_m * model.Y, sense=minimize)\n\n\nsolver = SolverFactory('glpk')\nstatus = solver.solve(model)\n\n# Results\nprint(\"X value:\", model.X.value)\nprint(\"Y value:\", model.Y.value)\nprint('Is extra cost applied?:', bool(model.Z.value))\nprint(\"Obj value:\", value(model.obj))\n\nX value: 10.0\nY value: 20.0\nIs extra cost applied?: False\nObj value: 400.0",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Example 1: Disjunction - Big-M formulation</span>"
    ]
  },
  {
    "objectID": "examples/disjunct-GDP.html",
    "href": "examples/disjunct-GDP.html",
    "title": "Example 2: Disjunction - GDP formulation",
    "section": "",
    "text": "Explanations will be added soon…\n\nfrom pyomo.environ import *\nfrom pyomo.gdp import *\n\nmodel = ConcreteModel()\n\n# Parameters\nmodel.C_ch = Param(within=NonNegativeReals, default=10)\nmodel.C_m = Param(domain=NonNegativeReals, default=15)\nmodel.Prod_ch = Param(domain=NonNegativeReals, default=2)\nmodel.Prod_m = Param(domain=NonNegativeReals, default=3)\nmodel.CAP = Param(domain=NonNegativeIntegers, default=100)\nmodel.O_min = Param(domain=NonNegativeIntegers, default=10)\nmodel.D_l = Param(domain=NonNegativeReals, default=20)\nmodel.D_c = Param(domain=NonNegativeReals, default=30)\n\n# GDP parameters\nmodel.Cextra = Param(within=NonNegativeReals, default=200)\nmodel.limit_cap = Param(within=NonNegativeIntegers, default=20)\n\n# Variables\nmodel.X = Var(domain=NonNegativeIntegers)\nmodel.Y = Var(domain=NonNegativeIntegers)\n\n# Constraints\nmodel.res1 = Constraint(expr=model.X + model.Y &gt;= model.O_min)\nmodel.res2 = Constraint(expr=model.Y &gt;= 2*model.X)\nmodel.res3 = Constraint(expr=model.X + model.Y &lt;= model.CAP)\nmodel.res4 = Constraint(expr=model.Prod_ch * model.X &gt;= model.D_l)\nmodel.res5 = Constraint(expr=model.Prod_m * model.Y &gt;= model.D_c)\n\nmodel.extra_cost_applies = Disjunct()\nmodel.extra_cost_applies.rule = Constraint(expr=model.X + model.Y &gt;= model.limit_cap)\nmodel.extra_cost_not_applies = Disjunct()\nmodel.extra_cost_not_applies.rule = Constraint(expr=model.X + model.Y &lt;= model.limit_cap)\nmodel.disj = Disjunction(expr=[model.extra_cost_applies, model.extra_cost_not_applies])\n\n# Objective\nmodel.obj = Objective(expr=model.C_ch * model.X + model.C_m * model.Y, sense=minimize)\n\n\nxfrm = TransformationFactory('gdp.bigm')\nxfrm.apply_to(model, bigM=1000)\nsolver = SolverFactory('glpk')\nstatus = solver.solve(model)\n\n# Results\nprint(\"X value:\", model.X.value)\nprint(\"Y value:\", model.Y.value)\nprint('Is extra cost applied?:', model.extra_cost_applies.indicator_var.value)\nprint(\"Obj value:\", value(model.obj))\n\nX value: 10.0\nY value: 20.0\nIs extra cost applied?: True\nObj value: 400.0",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Example 2: Disjunction - GDP formulation</span>"
    ]
  },
  {
    "objectID": "th-stochastic.html",
    "href": "th-stochastic.html",
    "title": "Uncertainty",
    "section": "",
    "text": "Stochastic, multistage programming\nIn practice some of the scheduling parameters may be uncertain. The exact duration of an activity, for instance, might not be known at the beginning of the project. Similarly, the number of available resources is another parameter that may not be known before project execution. These uncertainties may be due to different sources, including estimation errors, unforeseen (weather) conditions, late “delivery” (unavailability) of some required resources, unpredictable incidents such as machine breakdown or worker accidents, etc.\nBackground\nStochastic programming/optimization (optimal decision-making under uncertainty) is the part of mathematical programming and operations research that studies how to incorporate uncertainty into decision problems. Stochastic programs are primarily about transient decision making.\nAn information stage (normally simply called “stage”) is the most important concept that distinguishes stochastic programming. A stage is a point in time where decisions are made within a model. Stages define the boundaries of time intervals. Stages sometimes follow naturally from the problem setting and sometimes are modeling approximations.\nThe starting point of a stochastic program is the present situation. The model is intended to tell us what to do in light of our goals, constraints, and resources. We then ask what we should do. We are not asking what to do in all possible situations, just what to do based on our present state.\nFinding a good trade-off between time periods and stages is often crucial when modeling, as it has consequences for model quality, data collection, and solvability of the model.\nIn other words, one should not wait too long before taking a decision.\nMathematical Formulation\nIn the Figure we depict a generic multistage decision process with state \\(\\mathbf{x}_t\\) that evolves over time, starting at stage \\(t=1,\\) and then receives uncertain, exogenous inputs, \\(\\xi_2, \\xi_3, \\ldots, \\xi_T,\\) at given stages \\(t = 2,3,\\ldots, T.\\) At stage 1, a here-and-now (deterministic) decision is taken. The subsequent sequence of wait-and-see decision functions \\({\\mathbf{x}_t(\\xi_t)}_{t\\in [T]}\\) constitutes a policy, \\(\\pi.\\) The policy thus obtained, provides a decision rule for all stages \\(t \\in [T].\\) The aim of the decision process (stochastic multistage optimization) is then to compute an optimal policy for a given objective and subject to constraints.\nWe will describe in detail the two-stage problem, since the multistage is a straightforward generalisation. In the stochastic setting, we can naturally classify \\(x\\in\\mathscr{X}\\) as the first-stage decision variables, since the initial facilities1 are fixed and \\(y\\in\\mathbb{R}^{\\left|\\mathscr{A}\\right|\\times\\left|\\mathscr{K}\\right|}\\) as the second-stage decision variables, since the job-flow operating conditions are uncertain over time.\nThe two-stage stochastic linear program (Birge and Louveaux 2011), (Shapiro, Dentcheva, and Ruszczyński 2009) is then\n\\[\\begin{align} \\label{eq:2stage}\n\\min_{x\\in\\mathscr{X}} & \\,\\,c^{\\top}x + \\mathrm{E}\\left[Q(x;\\xi)\\right],\n\\end{align}\\] where \\(Q(x;\\xi)\\) is the optimal value of the second-stage problem \\[\\begin{align*}\n\\min_{y\\ge0} & \\,\\,q^{\\top}y\\\\\n\\textrm{s.t.} & \\,\\,Ny=0,\\\\\n& Cy\\ge d,\\\\\n& Sy\\le s,\\\\\n& Ry\\le Mx,\n\\end{align*}\\] where \\(d\\) is the (uncertain) resource demand, \\(s\\) is the (uncertain) resource supply, the random vector \\(\\xi=(q,d,s,R,M)\\) and \\(y=y(\\xi).\\) The expectation is taken with respect to the joint probability distribution function2 of \\(\\xi.\\) In the terminology of state-space, we can consider \\(x\\) as the state variable, and \\(y\\) as the control variable.\nTo treat the occurrence of infeasibility, where the first-stage solution does not satisfy the second-stage constraints, e.g. \\(Cy\\nleqslant d,\\) we introduce a recourse action \\(z\\) that supplies the deficit \\(d-Cy\\) at some penalty cost. Then the second-stage problem becomes \\[\\begin{align*}\n\\min_{y\\ge0} & \\,\\,q^{\\top}y+h^{\\top}z\\\\\n\\textrm{s.t.} & \\,\\,Ny=0,\\\\\n& Cy+z\\ge d,\\\\\n& Sy\\le s,\\\\\n& Ry\\le Mx,\n\\end{align*}\\] where \\(h\\) represents the vector of (positive) recourse costs.\nIn the multistage case, we will have a succession of recourse stages, yielding the multistage program (Powell 2022),\n\\[\n    \\min_{\\pi \\in \\Pi} \\mathrm{E} \\left[ \\sum^{T}_{t=1} \\gamma^{t-1} f_t(x_t;\\xi_t) \\right],\n\\] subject to \\[\n     x_t \\in \\mathcal{X}_t(x_{t-1};\\xi_{t-1}), \\quad t=1 \\ldots, T,\n\\] where \\(\\pi\\) is a policy, \\(\\gamma\\) is a discount factor, \\(f_t\\) is a cost function, \\(x_t\\) is a decision and \\(\\mathcal{X}_t\\) are the constraints. A policy is, by definition, a method that optimizes the objective. For example, in Google maps, the policy is to decide whether to turn left or right by optimizing over the time required to transverse the next link in the network plus the remaining time to get to the destination.\nNote that there are various forms of minimization in stochastic scheduling. Whenever an objective function has to be minimized, it has to be specified in what sense the objective has to be minimized.",
    "crumbs": [
      "Theory",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uncertainty</span>"
    ]
  },
  {
    "objectID": "th-stochastic.html#stochastic-multistage-programming",
    "href": "th-stochastic.html#stochastic-multistage-programming",
    "title": "Uncertainty",
    "section": "",
    "text": "Important\n\n\n\nSome decisions must be made today, but important information will not be available until after the decision is made.\n\n\n\n\n\nAn inherently two-stage model is a model where the first decision is a major long-term decision, whereas the remaining stages represent the use of this investment. In these cases, mathematically speaking, the first stage will look totally different from the remaining stages, which will all look more or less the same. This is a very important class of models, possibly the most important one for stochastic programming.\nIn inherently multistage models, all stages are of the same type. We face random resource availability, energy prices, unexpected maintenance, etc. We should not confuse information stages with time periods. Stages model the flow of information; time periods represent the ticking of the clock in a model. Stages, on the other hand, are points in time where we make decisions in the model after having learned something new.\n\n\n\n\n\n\n\n\nCaution\n\n\n\nIn the long run we are all dead. (J.M. Keynes)\n\n\n\n\n\n\n\n\n\n\nFigure 1.1: A multistage decision process with uncertainty. Uncertain, exogenous inputs \\(\\xi_t\\) arrive, starting from stage \\(t=2,\\) and trigger subsequent recourse actions.\n\n\n\n\n\n1 Data centers, HPC centers, networks. \n\n2 Either continuous or discrete, it is derived either from theory or observations, or both.\n\n\n\n\nExpectation sense is the crudest form of optimization, e.g., one wishes to minimize (a function of) the expected makespan, that is \\(\\mathrm{E}\\left[f\\left(C_{\\mathrm{max}}\\right)\\right],\\) and find a policy under which the expected makespan is smaller than the expected makespan under any other policy.\nStochastic sense is a stronger form of optimization. If a schedule or policy minimizes \\(f\\left(C_{\\mathrm{max}}\\right)\\) stochastically, then the makespan under the optimal schedule or policy is stochastically (in probability, or in law) less than the makespan under any other schedule or policy.",
    "crumbs": [
      "Theory",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uncertainty</span>"
    ]
  },
  {
    "objectID": "pyomo.html",
    "href": "pyomo.html",
    "title": "Using PYOMO",
    "section": "",
    "text": "Basic pyomo Linear Programming Example\nThis section details all the practical aspects of the optimal CDT scheduling. We intentionally provide a very general framework, but illustrate it with several simple examples.\nAs an introduction we load the necessary pyomo packages and solve an ultra-simple linear programming example. \\[\n\\begin{array}{ll}\n  \\min       & 2 x_1 + 3 x_2\\\\\n  \\mathrm{s.t.} & 3 x_1 + 4 x_2 \\geq 1\\\\\n             & x_1, x_2 \\geq 0\n\\end{array}\n\\]\nimport pyomo.environ as pyo \nfrom pyomo.opt import SolverFactory \n\nmodel = pyo.ConcreteModel(\"Simple Linear\")\n# Decision variables and domains\nmodel.x = pyo.Var([1,2], domain=pyo.NonNegativeReals)\n# Objective function\nmodel.OBJ = pyo.Objective(expr = 2*model.x[1] + 3*model.x[2])\n# Constraint(s)\nmodel.Constraint1 = pyo.Constraint(expr = 3*model.x[1] + 4*model.x[2] &gt;= 1)\n\nsolver = 'appsi_highs'\nSOLVER = pyo.SolverFactory(solver)\nassert SOLVER.available(), f\"Solver {solver} is not available.\"\n\n# Solve and print solution\nSOLVER.solve(model)\nprint(f\"x = ({pyo.value(model.x[1]):.2f}, {pyo.value(model.x[2]):.2f})\")\nprint(f\"optimal value = {pyo.value(model.OBJ):.2f}\")\n\nx = (0.33, 0.00)\noptimal value = 0.67\nWe can print out",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using PYOMO</span>"
    ]
  },
  {
    "objectID": "pyomo.html#basic-pyomo-linear-programming-example",
    "href": "pyomo.html#basic-pyomo-linear-programming-example",
    "title": "Using PYOMO",
    "section": "",
    "text": "pyomo.environ provides the framework for building the model\nSolverFactory allows to call the solver used to solve the optimization problem\n\n\n\n\nthe complete model;\na full trace of the optimization process.",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using PYOMO</span>"
    ]
  },
  {
    "objectID": "pyomo.html#disjunctions",
    "href": "pyomo.html#disjunctions",
    "title": "Using PYOMO",
    "section": "Disjunctions",
    "text": "Disjunctions\nThe decisions encountered in the CDT involve discrete, Boolean choices. These can take the following forms:\n\nSequencing decisions, where \\(A\\) ends before \\(B,\\) or \\(B\\) ends before \\(A.\\)\nSwitching decisions, where a facility is used or not.\nAlternative selection among a set of pricing policies, for example for alternative energy sources.\n\nThe general disjunctive problem is formulated as\n\\[\n\\begin{align}\n\\min \\quad &  z=f(x) + \\sum_{k \\in K} c_k & \\text{objective}\\\\\n\\text{s.t.} \\quad &   r(x) \\le 0 & \\text{global constraint} \\\\\n                  &  \\underset{j\\in J_{k}}{\\vee}\\left[\\begin{array}{c}\n                          Y_{jk}\\\\\n                          g_{jk}(x)\\le 0\\\\\n                          c_{k}=\\gamma_{jk}\n                             \\end{array}\\right]  & \\text{disjunctions} \\\\\n                  & \\underset{j\\in J_{k}}{\\veebar} Y_{jk} & \\text{disjunctions} \\\\\n                  & 0\\le x \\le U, \\; c_k \\in \\mathbb{R}, \\;  Y_{jk} = \\{\\text{True, False}\\}\n\\end{align}\\] If the Boolean variable is True both the inequalities and the cost equation are enforced; if the Boolean variable is False they are both ignored.\nFor sequencing decisions, between two tasks \\(i\\) and \\(j,\\) the disjuction is written as \\[\n\\left[\\begin{array}{c}\n            Y_{k}\\\\\n            s_i + d_i \\le s_j\\\\\n\\end{array}\\right] \\vee\n\\left[\\begin{array}{c}\n            \\neg Y_{k}\\\\\n            s_j + d_j \\le s_i\\\\\n\\end{array}\\right] ,\n\\] where \\(s_i,\\) \\(d_i\\) are the start and duration of task \\(i.\\)\n\nDisjunctive Programming in pyomo\nThe pyomo code for the disjunction is written as,\n@model.Disjunction(model.I, model.J) \ndef SequenceIJ(m, i, j):\n    return [ m.start[i] + duration[i] &lt;= m.start[j], \n             m.start[j] + duration[j] &lt;= m.start[i] ]\nWhen faced with such a choice among exclusive options, to convert the problem to a MILP formulation we can resort to disjunctive programming based on:\n\nBig-M formulation.\nConvex hull formulation.\n\nConsider the disjunction \\(A \\veebar B \\veebar C,\\) as depicted below. The two possible formulations are:\n\n\n\n\n\n\n\nBig-M\nConvex Hull\n\n\n\n\n\n\n\n\n\nLooser relaxation\nSmaller problems\n\n\nTighter relaxation\nBigger problems\n\n\n\n\nThe respective code lines in the pyomo generalized disjunctive programming gdp module, are\n# Big-M\nTransformationFactory('gdp.bigm')\n# Convex Hull\nTransformationFactory('gdp.chull')\n\n\n\n\n\n\nCaution\n\n\n\nThe disjunctive formulations will always increase the number of variables and constraints of the optimization problem. Thus, they are usually only profitable for long time horizon problems.\n\n\n\n\n\n\n\n\nNote\n\n\n\nFor the CDT, in addition to sequencing constraints, the resource constraints must also be satisfied. This is important for jobs that can in theory be executed in parallel, but might in practice have a resource conflict and will need to be executed sequentially.\n\n\n\n\nBig-M Method\nThe big-M method converts the logical disjunction “\\(i\\) before \\(j\\)” OR “\\(j\\) before \\(i\\)” into a system of linear inequalities with binary variables. The formulation is\n\\[\n\\begin{align}\n   S_j  & \\geq S_i + d_i - M(1 - y_{ij}), \\\\\n   S_i  & \\geq S_j + d_j - My_{ij},\n\\end{align}\\] where \\(S_i\\) is the starting time, \\(d_i\\) the duration and \\(M\\) is a large enough positive constant, usually set to the upper bound on the makespan. When activity \\(i\\) precedes \\(j,\\) then \\(y_{ij} =1\\) and the first inequality ensures that \\(j\\) starts after \\(i\\) has finished, whereas the second inequality is trivially satisfied and has no effect. On the other hand, if activity \\(j\\) precedes \\(i,\\) then \\(y_{ij} =0\\) and the first inequality is inoperant, whereas the second ensures that \\(i\\) starts after \\(j\\) has finished.\n\n\nGDP OPT\nDisjunctive programming is useful in certain situations since it is better than “forcing” a given constraint into a MI(N)LP form through complicated tricks.\nPYOMO includes a generalized disjunctive programming pack, GDP.opt, that accepts pure disjunctions and then uses specialized logic-based decompositions methods to solve the problem, without the need for prior conversion to MI(N)LP, as discussed above. The benefit of using a disjunctive programming formulation lies in its ability to preserve and leverage the intrinsic logical framework of the problem at hand, thereby mitigating its combinatorial complexity.\n\n\nTight Formulations\nBasically all MILP problems are solved by branch-and-bound methods. The performance of a branch-and-bound method can greatly improve by having a tight problem formulation, that is, one where the gap between the feasible region of the original problem and its linear relaxation is small. Such a tight formulation typically leads to better bounds and, therefore, more pruning of subproblems, speeding up computation. The extreme case is to use the convex hull for the formulation.\nFinding a tight formulation for a specific problem is an art that requires experience with mathematical modeling. Some “rules of thumb” here are to\n\nhave as few as possible big-M constraints with the large constants \\(M,\\)\navoid having superfluous decision variables, and\navoid formulating as inequality a relation that should hold with equality for the optimal solution.",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using PYOMO</span>"
    ]
  },
  {
    "objectID": "CDT.html",
    "href": "CDT.html",
    "title": "CDT Implementation",
    "section": "",
    "text": "Input File\nBefore addressing the simple examples of resource scheduling and the use cases, we describe the overall implementation, as shown in Figure 5.1.\nThis json input file contains a complete description of the CDT that we want to model for optimization. Thanks to its genericity, it can be readily adapted to a wide diversity of projects, and even to global job scheduling at national or European levels.\nThe input file contains all the information regarding the following characteristics of the CDT:",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>CDT Implementation</span>"
    ]
  },
  {
    "objectID": "CDT.html#input-file",
    "href": "CDT.html#input-file",
    "title": "CDT Implementation",
    "section": "",
    "text": "\\(\\mathcal{P} = \\{P_1, P_2, \\ldots \\}\\) the list of projects;\n\\(\\mathcal{J}_i = \\{J_1^i, J_2^i, \\ldots \\}\\) the list of jobs per project1;\n\\(\\mathcal{O}_j = \\{O_1^j, O_2^j, \\ldots \\}\\) the list of operations per job2;\n\\(\\mathcal{M}_k = \\{M_1^k, M_2^k, \\ldots \\}\\) the list of modes per job (operation)3;\nResources:\n\n\\(\\mathcal{R}_l^{\\rho} = \\{R_1^l, R_2^l, \\ldots \\}\\) list of renewable resources per mode;\n\\(\\mathcal{R}_l^{\\nu} = \\{R_1^l, R_2^l, \\ldots \\}\\) list of non-renewable resources per project;\n\nJob requirements per resource: \\(p_{ij}\\)\nCosts per resource: \\(c_{ij,l}\\)\nList of precedences4: \\(\\mathcal{E} = \\{(i,j) \\mid i \\prec j, \\, i,j \\in \\mathcal{J} \\}.\\)\n\n1 These are of type data transfer, data storage, data processing, etc.2 This is an optional sub-group–the operations can just be considered as additional jobs.3 These are the facilities that can be exploited for each category of job: networks, data centers, HPC centers, etc.4 Successors and/or predecessors, as defined by the workflow DAG.",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>CDT Implementation</span>"
    ]
  },
  {
    "objectID": "CDT.html#data-model-overview",
    "href": "CDT.html#data-model-overview",
    "title": "CDT Implementation",
    "section": "Data Model Overview",
    "text": "Data Model Overview\nThe input consists of four entities:\n\n\n\n\n\n\n\nEntity\nDescription\n\n\n\n\nResources\nAvailable resources with capacities (renewable per period, non-renewable)\n\n\nJobs\nUnits of work to be scheduled\n\n\nModes\nAlternative execution options for each job\n\n\nPrecedences\nDirected edges defining the execution order (DAG)\n\n\n\n\n1. Resources\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\nresource_id\nstring\nyes\nUnique identifier for the resource\n\n\nname\nstring\nno\nHuman-readable name\n\n\ncapacity\ninteger ≥ 0\nyes\nMaximum units available per time period5\n\n\n\n5 For renewable resources. If resource is non-renewable, this is the total available.\n\n2. Jobs\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\njob_id\nstring\nyes\nUnique identifier for the job\n\n\nname\nstring\nno\nHuman-readable name\n\n\nrelease_time\ninteger ≥ 0\nno\nEarliest start time (default: 0)\n\n\ndeadline\ninteger ≥ 0\nno\nLatest finish time (default: none)\n\n\n\n\n\n3. Modes\nEach job must have at least one mode. A mode specifies how a job can be executed.\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\nmode_id\nstring\nyes\nUnique identifier for the mode\n\n\njob_id\nstring\nyes\nReference to parent job\n\n\nduration\ninteger ≥ 0\nyes\nProcessing time in periods\n\n\ncost\nfloat ≥ 0\nyes\nCost of selecting this mode\n\n\nresource_requirements\nlist\nyes\nResources consumed during execution\n\n\n\n\nResource Requirement (nested within Mode)\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\nresource_id\nstring\nyes\nReference to a defined resource\n\n\ndemand\ninteger ≥ 0\nyes\nUnits required per period while job executes\n\n\n\n\n\n\n4. Precedences\nDefines the DAG structure. Each entry represents a directed edge.\n\n\n\n\n\n\n\n\n\nField\nType\nRequired\nDescription\n\n\n\n\npredecessor\nstring\nyes\njob_id of the job that must finish first\n\n\nsuccessor\nstring\nyes\njob_id of the job that must start after\n\n\nlag\ninteger ≥ 0\nno\nMinimum time gap between finish and start (default: 0)\n\n\n\nThis gives the following json format.\n\n\nShow Input File Code\n\n{\n  \"problem_name\": \"string (optional)\",\n  \"horizon\": \"integer (optional, planning horizon)\",\n  \n  \"resources\": [\n    {\n      \"resource_id\": \"string\",\n      \"name\": \"string (optional)\",\n      \"capacity\": \"integer\"\n    }\n  ],\n  \n  \"jobs\": [\n    {\n      \"job_id\": \"string\",\n      \"name\": \"string (optional)\",\n      \"release_time\": \"integer (optional, default 0)\",\n      \"deadline\": \"integer (optional, default null)\"\n    }\n  ],\n  \n  \"modes\": [\n    {\n      \"mode_id\": \"string\",\n      \"job_id\": \"string\",\n      \"duration\": \"integer\",\n      \"cost\": \"number\",\n      \"resource_requirements\": [\n        {\n          \"resource_id\": \"string\",\n          \"demand\": \"integer\"\n        }\n      ]\n    }\n  ],\n  \n  \"precedences\": [\n    {\n      \"predecessor\": \"string (job_id)\",\n      \"successor\": \"string (job_id)\",\n      \"lag\": \"integer (optional, default 0)\"\n    }\n  ]\n}\n\nValidation\nWe provide a JSON schema that the user can use for formal validation of their input files as follows.\nimport json\nimport jsonschema\nfrom jsonschema import validate\nimport DraftValidator\n\n# Load schema and data\nwith open(\"workflow-schema.json\") as f:\n    schema = json.load(f)\n\nwith open(\"my-problem.json\") as f:\n    data = json.load(f)\n\n# Validate\ntry:\n    validate(instance=data, schema=schema)\n    print(\"Input is valid.\")\nexcept jsonschema.ValidationError as e:\n    print(f\"Validation error: {e.message}\")\n    print(f\"Path: {list(e.absolute_path)}\")",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>CDT Implementation</span>"
    ]
  },
  {
    "objectID": "CDT.html#model-function",
    "href": "CDT.html#model-function",
    "title": "CDT Implementation",
    "section": "Model Function",
    "text": "Model Function\nAll the above are necessary and sufficient for the mathematical formulation presented in the section Mathematical Formulation - Deterministic Model. We define a pyomo function that takes a dictionary of tasks as input6, and returns a pyomo model.\n6 See below for examples.# Model function generator\ndef MRCPSP_model(TASKS):\n    model = pyo.ConcreteModel()\n    # tasks is a two dimensional set of (j,m) constructed from the dictionary keys\n    model.TASKS = pyo.Set(initialize=TASKS.keys(), dimen=2)\n    # the set of jobs is constructed from a python set\n    model.JOBS = pyo.Set(initialize=list(set([j for (j, m) in model.TASKS])))\n    # set of machines is constructed from a python set\n    model.MACHINES = pyo.Set(initialize=list(set([m for (j, m) in model.TASKS])))\n    # the order of tasks is constructed as a cross-product of tasks and filtering\n    model.TASKORDER = pyo.Set(\n        initialize = model.TASKS * model.TASKS,\n        dimen      = 4,\n        filter     = lambda model, j, m, k, n: (k, n) == TASKS[(j, m)][\"prec\"],\n    )\n    # the set of disjunctions is cross-product of jobs, jobs, and machines\n    model.DISJUNCTIONS = pyo.Set(\n        initialize = model.JOBS * model.JOBS * model.MACHINES,\n        dimen      = 3,\n        filter     = lambda model, j, k, m: j &lt; k\n                     and (j, m) in model.TASKS\n                     and (k, m) in model.TASKS,\n    )\n    # load duration data into a model parameter for later access\n    @model.Param(model.TASKS)\n    def dur(model, j, m):\n        return TASKS[(j, m)][\"dur\"]\n    # establish an upper bound on makespan\n    ub = sum([model.dur[j, m] for (j, m) in model.TASKS])\n    # create decision variables\n    model.makespan = pyo.Var(bounds=(0, ub))\n    model.start = pyo.Var(model.TASKS, bounds=(0, ub))\n    \n    @model.Objective(sense=pyo.minimize)\n    def minimize_makespan(model):\n        return model.makespan\n    \n    @model.Constraint(model.TASKS)\n    def finish_tasks(model, j, m):\n        return model.start[j, m] + model.dur[j, m] &lt;= model.makespan\n\n    @model.Constraint(model.TASKORDER)\n    def preceding(model, j, m, k, n):\n        return model.start[k, n] + model.dur[k, n] &lt;= model.start[j, m]\n\n    @model.Disjunction(model.DISJUNCTIONS)\n    def no_overlap(model, j, k, m):\n        return [\n            model.start[j, m] + model.dur[j, m] &lt;= model.start[k, m],\n            model.start[k, m] + model.dur[k, m] &lt;= model.start[j, m],\n        ]\n\n    pyo.TransformationFactory(\"gdp.bigm\").apply_to(model)\n    return model\n# Generate the model\nMRCPSP_model(TASKS)",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>CDT Implementation</span>"
    ]
  },
  {
    "objectID": "CDT.html#optimization",
    "href": "CDT.html#optimization",
    "title": "CDT Implementation",
    "section": "Optimization",
    "text": "Optimization\nThe optimization can be performed by calling one of the built-in solvers of pyomo, or by using one of the more efficient commercial7 solvers, from CPLEX or gurobi.\n7 Free academic versions are available.# model optimization\ndef MRCPSP_solve(model):\n    SOLVER.solve(model)\n    results = [\n        {\n            \"Job\": j,\n            \"Machine\": m,\n            \"Start\": model.start[j, m](),\n            \"Duration\": model.dur[j, m],\n            \"Finish\": model.start[(j, m)]() + model.dur[j, m],\n        }\n        for j, m in model.TASKS\n    ]\n    return results\n# select a suitable solver\nsolver = 'appsi_highs' #'gurobi' 'glpk','cbc','cplex'\nSOLVER = pyo.SolverFactory(solver)\nassert SOLVER.available(), f\"Solver {solver} is not available.\"\n# Solve the optimization problem\nresults = MRCPSP_solve(MRCPSP_model(TASKS))",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>CDT Implementation</span>"
    ]
  },
  {
    "objectID": "CDT.html#output",
    "href": "CDT.html#output",
    "title": "CDT Implementation",
    "section": "Output",
    "text": "Output\nFinally, we extract the schedule from the results, store them in a suitable dataframe, and output a CSV file with start and finish times of each job, as well as the optimal mode selected for each job. This can also be output in the form of a GANTT chart. Other outputs can include resource usage, energy consumption, machine utilization statistics and costs.",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>CDT Implementation</span>"
    ]
  },
  {
    "objectID": "CDT.html#time-windows---ef-lf-etc.",
    "href": "CDT.html#time-windows---ef-lf-etc.",
    "title": "CDT Implementation",
    "section": "Time-Windows - EF, LF, etc.",
    "text": "Time-Windows - EF, LF, etc.\nTo reduce the number of variables in the MILP optimization, we define subsets of the time variable. Recall: the timespan \\([0,T]\\) is discretized into \\(T\\) time periods of length one. Period \\(t\\) refers to the time slot/interval \\([t-1,t],\\) where \\(t=1, \\ldots, T.\\) The processing time (duration) of job \\(j\\) is denoted \\(d_j,\\) the set of immediate predecessor activities of activity \\(j\\) is denoted \\(\\mathcal{P}_j\\) and the set of immediate successor activities of activity \\(j\\) is denoted \\(\\mathcal{S}_j.\\)\nThe forward pass to compute earliest start and finishing times is defined as follows:\nEST[0], EFT[0] = 0 # initialization\nfor j in range(2, n):\n  EST[j] = max(EFT[i] for i in P[j])\n  EFT[j] = EST[j] + d[j]\nThe backward pass to compute latest start and finishing times is defined as follows:\nLFT[0], LST[0] = T # initialization\nfor j in range(n-1, 1, -1):\n  LFT[j] = min(LST[i] for i in S[j])\n  LST[j] = LFT[j] - d[j]",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>CDT Implementation</span>"
    ]
  },
  {
    "objectID": "RCPSP.html",
    "href": "RCPSP.html",
    "title": "Examples",
    "section": "",
    "text": "Simplified Supply Chain Example\nPutting together:",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Examples</span>"
    ]
  },
  {
    "objectID": "RCPSP.html#simplified-supply-chain-example",
    "href": "RCPSP.html#simplified-supply-chain-example",
    "title": "Examples",
    "section": "",
    "text": "precedence\nTBC",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Examples</span>"
    ]
  },
  {
    "objectID": "RCPSP.html#simplified-rcpsp-example",
    "href": "RCPSP.html#simplified-rcpsp-example",
    "title": "Examples",
    "section": "Simplified RCPSP Example",
    "text": "Simplified RCPSP Example\nPutting together:\n\nprecedence\ntime-indexed\ndisjunctive",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Examples</span>"
    ]
  },
  {
    "objectID": "RCPSP.html#simplified-mrcpsp-example",
    "href": "RCPSP.html#simplified-mrcpsp-example",
    "title": "Examples",
    "section": "Simplified MRCPSP Example",
    "text": "Simplified MRCPSP Example\nIn this example we have 4 jobs, 2 possible modes, 1 renewable resource and no non-renewable resources. Jobs 2 and 3 can be executed in mode 1 or in mode 2.\n\n\n\n\n\n\n\n\ngraph LR\n    A[\"$$J_0$$\"] --&gt; B(\"$$J_1$$\")\n    A --&gt; C(\"$$J_2$$\")\n    B --&gt; D(\"$$J_3$$\")\n    C --&gt; E(\"$$J_4$$\")\n    D --&gt; F[\"$$J_5$$\"]\n    E --&gt; F\n\n\n\n\n\n\n\n\n\nFigure 6.1: A project network represented as a directed acyclic graph (DAG) for a workflow with 4 processing jobs \\(J_1,\\cdots, J_4.\\) The tasks 0 and 5 are dummy tasks, representing the start and the end of the workflow.\n\n\n\nThe project instance, shown above, is detailed in Table 1, where \\(S_j\\) is the successor list of job \\(j,\\) \\(m\\) is the mode, \\(d_{jm}\\) is the job duration, \\(k^{\\rho}_{jm1}\\) is the renewable resource requirement, \\(R^{\\rho}\\) is the renewable resource list, \\(K^{\\rho}\\) is the renewable resource limit, and \\(R^{\\nu}\\) is the non-renewable resource list, taken as empty. In other words we have 4 jobs, 2 possible modes, 1 renewable resource and no non-renewable resources. Jobs 2 and 3 can be executed in mode 1 or in mode 2.\n\\[\\begin{aligned}\n& \\text {Table 1. Multi-mode RCPSP for a 4-job, 2-mode workflow. }\\\\\n&\\begin{array}{cccccccc}\n%\\begin{tabular}{|c|c|c|c|c|c|c|c|}\n\\hline\nj & S_{j}& m & d_{jm} & k^{\\rho}_{jm1} & R^{\\rho} & K^{\\rho}_{1} & R^{\\nu}\\\\\n\\hline\n0 & \\left\\{ 1,2\\right\\}  & 1 & 0 & 0 & \\left\\{ 1\\right\\}  & 3 & \\emptyset \\\\\n1 & \\left\\{ 3\\right\\}  & 1 & 2 & 2  &  &  & \\\\\n2 & \\left\\{ 4\\right\\}  & 1 & 2 & 2 &  &  & \\\\\n&  & 2 & 3 & 1 &  &  & \\\\\n3 & \\left\\{ 5\\right\\}  & 1 & 1 & 3 &  &  & \\\\\n&  & 2 & 2 & 1 &  &  & \\\\\n4 & \\left\\{ 5\\right\\}  & 1 & 2 & 3 &  &  & \\\\\n5 & \\emptyset & 1 & 0 & 0 &  &  & \\\\\n\\hline\n%\\end{tabular}\n\\end{array}\n\\end{aligned}\\]\nInput File\nThe simplest input file is a direct transcription of the table of variables.\n{\n  \"0\":{\"suc\":(\"1\",\"2\"),\"mod\":\"A\",\"drt\":0,    \"rsc\":0},\n  \"1\":{\"suc\":\"3\",\"mod\":\"A\",      \"drt\":2,    \"rsc\":2},\n  \"2\":{\"suc\":\"4\",\"mod\":(\"A\",\"B\"),\"drt\":[2,3],\"rsc\":[2, 1]},\n  \"3\":{\"suc\":\"5\",\"mod\":(\"A\",\"B\"),\"drt\":[1,2],\"rsc\":[3, 1]},\n  \"4\":{\"suc\":\"5\",\"mod\":\"A\",      \"drt\":2,    \"rsc\":3},\n  \"5\": {\"suc\":\"\",\"mod\":\"A\",      \"drt\":0,    \"rsc\":0 }\n}\nimport json\n\nwith open(\"input.json\", \"r\") as jsonfile: \n    TASKS = json.load(jsonfile)\nThough, for interoperability, we should privilege the data model format, described before.",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Examples</span>"
    ]
  },
  {
    "objectID": "RCPSP.html#silly-examples",
    "href": "RCPSP.html#silly-examples",
    "title": "Examples",
    "section": "Silly Examples",
    "text": "Silly Examples\nIn summary, this book has no content whatsoever.\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()\n\n\n\n\n\n\n\nFigure 6.2: A line plot\n\n\n\n\n\nWe observe in Figure 6.2 that there is a clear trend, up and down.\nTo only have code displayed, but not executed…\n#| label: fig-line-plot\n#| fig-cap: \"A line plot \"\n\nimport matplotlib.pyplot as plt\nplt.plot([1,23,2,4])\nplt.show()",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Examples</span>"
    ]
  },
  {
    "objectID": "usecases.html",
    "href": "usecases.html",
    "title": "Use-Cases",
    "section": "",
    "text": "DDFACET\nThe workflow is quite simple, with choice of HPC centers, data centers and network connections. The batch size is large and so are the data volumes. For these reasons, optimal scheduling that takes into account facility availability and reliability, is very important.\nTBC\nTBC\nTBC",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Use-Cases</span>"
    ]
  },
  {
    "objectID": "usecases.html#nsbas",
    "href": "usecases.html#nsbas",
    "title": "Use-Cases",
    "section": "NSBAS",
    "text": "NSBAS\nTBC\nTBC\nTBC",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Use-Cases</span>"
    ]
  },
  {
    "objectID": "th-stochastic.html#value-at-risk",
    "href": "th-stochastic.html#value-at-risk",
    "title": "Uncertainty",
    "section": "Value at Risk",
    "text": "Value at Risk\nWhen the uncertainty is in the constraints, we can ensure that they hold with a certain probability. Suppose the constraints are of the form \\[ A(z) x - b(z) \\le 0 ,\n\\] where \\(x\\) is the decision variable and \\(z\\) is the random variable. Then the chance constraint can be \\[ \\mathrm{P} \\left( a_i(z)^{\\top} x - b_i(z) \\le 0, \\; \\forall \\; i=1,\\ldots, m \\right) \\ge 1 - \\epsilon\n\\] for some \\(\\epsilon \\in (0,1).\\)\n\n\n\n\nBirge, John R., and François Louveaux. 2011. Introduction to Stochastic Programming. Second edition. Springer New York, NY. https://doi.org/10.1007/978-1-4614-0237-4.\n\n\nPowell, Warren B. 2022. Reinforcement Learning and Stochastic Optimization: A Unified Framework for Sequential Decisions. John Wiley & Sons.\n\n\nShapiro, Alexander, Darinka Dentcheva, and Andrzej Ruszczyński. 2009. Lectures on Stochastic Programming. SIAM, Society for Industrial; Applied Mathematics. https://doi.org/10.1137/1.9780898718751.",
    "crumbs": [
      "Theory",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uncertainty</span>"
    ]
  },
  {
    "objectID": "th-stochastic.html#chance-constraints",
    "href": "th-stochastic.html#chance-constraints",
    "title": "Uncertainty",
    "section": "Chance Constraints",
    "text": "Chance Constraints\nWhen the uncertainty is in the constraints, we can ensure that they hold with a certain probability. Suppose the constraints are of the form \\[ A(z) x - b(z) \\le 0 ,\n\\] where \\(x\\) is the decision variable and \\(z\\) is the random variable. Then the chance constraint can be \\[ \\mathrm{P} \\left( a_i(z)^{\\top} x - b_i(z) \\le 0, \\; \\forall \\; i=1,\\ldots, m \\right) \\ge 1 - \\epsilon\n\\] for some \\(\\epsilon \\in (0,1).\\)",
    "crumbs": [
      "Theory",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uncertainty</span>"
    ]
  },
  {
    "objectID": "th-stochastic.html#risk-measures",
    "href": "th-stochastic.html#risk-measures",
    "title": "Uncertainty",
    "section": "Risk Measures",
    "text": "Risk Measures\nRisk measures attempt to combine the two previous ones: expectations, and probabilities of constraint violations. One example is given by \\[\n\\max_{x\\ge 0} \\mathrm{E}_z f(x,z) - \\kappa \\mathrm{Var} \\left( f(x,z) \\right),\n\\] where \\(\\kappa\\) is a risk aversion parameter. The larger the value of \\(\\kappa,\\) the more the optimization problem tries to find a solution with minimal variance, or less risk.\n\n\n\n\n\n\nNoteRisk Measure\n\n\n\nA risk measure \\(\\rho\\) combines the expected value \\(\\mathrm{E}_z f(x,z)\\) with another scalar term, called dispersion measure, which measures the uncertainty of the outcome.\n\n\nThe most common risk measures are:\n\nThe mean-variance model, \\[ \\rho(Z) = \\mathrm{E}_(Z) - \\kappa \\mathrm{Var} (Z) . \\]\nThe value-at-risk (VaR), \\[\\rho(Z) = \\mathrm{E}_(Z) - \\kappa \\mathrm{VaR}_{\\alpha} (Z),\\] where \\[\\mathrm{VaR}_{\\alpha} (Z) = \\inf \\{ t \\colon   \\mathrm{P}(Z \\le t ) \\ge \\alpha \\} .\\]\nThe conditional value-at-risk (CVaR), \\[\\rho(Z) = \\mathrm{CVaR}_{\\alpha} (Z),\\] where \\[\\mathrm{CVaR}_{\\alpha} (Z) = \\mathrm{E} \\{ Z \\vert Z \\ge \\mathrm{VaR}_{\\alpha} (Z)  \\} .\\]\nExponential risk aversion, \\[\\rho(Z) = \\inf_{\\gamma &gt; 0} \\frac{1}{\\gamma} \\log \\mathrm{E} \\left( \\exp(\\gamma Z) \\right). \\]\n\nNote that \\(\\mathrm{VaR}_{\\alpha} (Z)\\) can be rewritten as \\(\\mathrm{P} (Z \\le \\epsilon ) \\ge \\alpha.\\) Finally, selecting the “right” function \\(\\rho\\) depends on the modeling and optimization goals one has in mind.",
    "crumbs": [
      "Theory",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uncertainty</span>"
    ]
  },
  {
    "objectID": "th-stochastic.html#robust-optimization",
    "href": "th-stochastic.html#robust-optimization",
    "title": "Uncertainty",
    "section": "Robust Optimization",
    "text": "Robust Optimization\nIn addition to the above two approaches—stochastic optimization and risk measures—there is a third approach, robust optimization, which is based on a worst-case analysis. we want the optimal solution to perform “the best possible,” assuming that the unknown problem parameters can always turn out to be “the worst possible.”\n\\[\\begin{align*}\n\\min & \\sup_{z \\in Z} \\left[(c+Cz)^{\\top} x \\right] \\\\\n\\textrm{s.t.} & \\quad (a_i + A_i z)^{\\top} x \\le b_i +b_i^{\\top} Z,  \\, i=1,\\ldots,m, \\, \\forall z \\in Z,\\\\\n& \\quad x\\in \\mathbb{R}^n ,\n\\end{align*}\\] where \\(Z\\) is the uncertainty set, and any single element \\(z \\in Z\\) is a scenario.\nA typical pattern emerges when comparing the solution between average-case stochastic optimization and robust optimization. The robust solution’s “range” of values is narrower, both in the best- and worst-situation sense, and it gives stabler profit relations. This comes, however, at the expense of having worse performance in an “average” scenario.\nYou can expect to observe this kind of phenomenon very often whenever you need to solve a problem under uncertainty and are unsure whether the worst-case or average-case performance should be optimized. The degree of trade-off can help you make the right decision.\n\n\n\n\nBirge, John R., and François Louveaux. 2011. Introduction to Stochastic Programming. Second edition. Springer New York, NY. https://doi.org/10.1007/978-1-4614-0237-4.\n\n\nPowell, Warren B. 2022. Reinforcement Learning and Stochastic Optimization: A Unified Framework for Sequential Decisions. John Wiley & Sons.\n\n\nShapiro, Alexander, Darinka Dentcheva, and Andrzej Ruszczyński. 2009. Lectures on Stochastic Programming. SIAM, Society for Industrial; Applied Mathematics. https://doi.org/10.1137/1.9780898718751.",
    "crumbs": [
      "Theory",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uncertainty</span>"
    ]
  },
  {
    "objectID": "examples/02-Disjunctions-GDPopt.html",
    "href": "examples/02-Disjunctions-GDPopt.html",
    "title": "Example 3: GDPopt Test",
    "section": "",
    "text": "This basic example of the use of GDP (General Disjunctive Modeling) is taken from the pyomo doc. The GDPopt solver in Pyomo allows users to solve nonlinear Generalized Disjunctive Programming (GDP) models using logic-based decomposition approaches, as opposed to the conventional approach via reformulation to a Mixed Integer Nonlinear Programming (MINLP) model.\n\\[\n\\begin{aligned}\n\\min_{x,\\, y} \\quad & x + 0.1\\, y \\\\[6pt]\n\\text{s.t.} \\quad & x + y = 1 \\\\[4pt]\n& \\begin{bmatrix} x = 0 \\end{bmatrix} \\;\\vee\\; \\begin{bmatrix} y = 0 \\end{bmatrix} \\\\[4pt]\n& -1.2 \\leq x \\leq 2 \\\\\n& -10 \\leq y \\leq 10\n\\end{aligned}\n\\]\nThe disjunction \\([\\,x=0\\,] \\vee [\\,y=0\\,]\\) is a GDP (Generalized Disjunctive Program) constraint: at least one of the two bracketed sub-problems must hold. Combined with the equality \\(x + y = 1\\), the two feasible cases are:\n\n\n\nActive disjunct\n\\(x\\)\n\\(y\\)\nObjective\n\n\n\n\n\\(x = 0\\)\n\\(0\\)\n\\(1\\)\n\\(0 + 0.1(1) = \\mathbf{0.1}\\)\n\n\n\\(y = 0\\)\n\\(1\\)\n\\(0\\)\n\\(1 + 0.1(0) = 1.0\\)\n\n\n\nSo the optimal solution is \\(x^* = 0,\\ y^* = 1\\) with objective value \\({0.1}\\), achieved by activating the first disjunct.\nThe LOA (Logic-based Outer Approximation) solver finds this by introducing binary indicator variables \\(z_1, z_2 \\in \\{0,1\\}\\) with \\(z_1 + z_2 \\geq 1\\) and enforcing the disjunct constraints only when the corresponding indicator is active.\n\nimport pyomo.environ as pyo\nfrom pyomo.gdp import Disjunct, Disjunction\n\nmodel = pyo.ConcreteModel(name='LOA example')\n\nmodel.x = pyo.Var(bounds=(-1.2, 2))\nmodel.y = pyo.Var(bounds=(-10,10))\nmodel.c = pyo.Constraint(expr= model.x + model.y == 1)\n\nmodel.fix_x = Disjunct()\nmodel.fix_x.c = pyo.Constraint(expr=model.x == 0)\n\nmodel.fix_y = Disjunct()\nmodel.fix_y.c = pyo.Constraint(expr=model.y == 0)\n\nmodel.d = Disjunction(expr=[model.fix_x, model.fix_y])\n\nmodel.objective = pyo.Objective(expr=model.x + 0.1*model.y, sense=pyo.minimize)\n\nresults = pyo.SolverFactory('gdpopt.loa').solve(\n    model, mip_solver='glpk', tee=True)\n\nmodel.display()\n\nStarting GDPopt version 22.5.13 using LOA algorithm\niterlim: None\ntime_limit: None\ntee: true\nlogger: &lt;Logger pyomo.contrib.gdpopt (INFO)&gt;\ninteger_tolerance: 1.0e-05\nconstraint_tolerance: 1.0e-06\nvariable_tolerance: 1.0e-08\nsubproblem_initialization_method: &lt;function restore_vars_to_original_values at 0x108c374c0&gt;\ncall_before_subproblem_solve: &lt;class 'type'&gt;\ncall_after_subproblem_solve: &lt;class 'type'&gt;\ncall_after_subproblem_feasible: &lt;class 'type'&gt;\nforce_subproblem_nlp: false\nsubproblem_presolve: true\ntighten_nlp_var_bounds: false\nround_discrete_vars: true\nmax_fbbt_iterations: 3\ninit_strategy: None\ninit_algorithm: set_covering\ncustom_init_disjuncts: []\nmax_slack: 1000.0\nOA_penalty_factor: 1000.0\nset_cover_iterlim: 8\ndiscrete_problem_transformation: gdp.bigm\ncall_before_discrete_problem_solve: &lt;class 'type'&gt;\ncall_after_discrete_problem_solve: &lt;class 'type'&gt;\ncall_before_master_solve: &lt;class 'type'&gt;\ncall_after_master_solve: &lt;class 'type'&gt;\nmip_presolve: true\ncalc_disjunctive_bounds: false\nobbt_disjunctive_bounds: false\nmip_solver: glpk\nmip_solver_args:\nnlp_solver: ipopt\nnlp_solver_args:\nminlp_solver: baron\nminlp_solver_args:\nlocal_minlp_solver: bonmin\nlocal_minlp_solver_args:\nsmall_dual_tolerance: 1.0e-08\nbound_tolerance: 1.0e-06\n\nIf you use this software, you may cite the following:\n            - Implementation:\n            Chen, Q; Johnson, ES; Bernal, DE; Valentin, R; Kale, S;\n            Bates, J; Siirola, JD; Grossmann, IE.\n            Pyomo.GDP: an ecosystem for logic based modeling and optimization\n            development.\n            Optimization and Engineering, 2021.\n\n- LOA algorithm:\n        Türkay, M; Grossmann, IE.\n        Logic-based MINLP algorithms for the optimal synthesis of process\n        networks. Comp. and Chem. Eng. 1996, 20(8), 959–978.\n        DOI: 10.1016/0098-1354(95)00219-7.\nOriginal model has 3 constraints (0 nonlinear) and 1 disjunctions, with 4 variables, of which 2 are binary, 0 are integer, and 2 are continuous.\n---Starting GDPopt initialization---\nStarting set covering initialization.\n=============================================================================================\nIteration | Subproblem Type | Lower Bound | Upper Bound |   Gap    | Time(s)\n\nInitialization complete.\nFinished discrete problem initialization in 0.00s and 0 iterations \n\n=============================================================================================\nIteration | Subproblem Type | Lower Bound | Upper Bound |   Gap    | Time(s)\n\n        1          discrete       0.10000           inf       nan%      0.06  \n        1        subproblem       0.10000       0.10000      0.00%      0.07  *\n        1                         0.10000       0.10000      0.00%      0.07  \nGDPopt exiting--bounds have converged or crossed.\n\nSolved in 1 iterations and 0.07433 seconds\nOptimal objective value 0.1000000000\nRelative optimality gap 0.00000%\nModel LOA example\n\n  Variables:\n    x : Size=1, Index=None\n        Key  : Lower : Value : Upper : Fixed : Stale : Domain\n        None :  -1.2 :     0 :     2 : False : False :  Reals\n    y : Size=1, Index=None\n        Key  : Lower : Value : Upper : Fixed : Stale : Domain\n        None :   -10 :     1 :    10 : False : False :  Reals\n\n  Objectives:\n    objective : Size=1, Index=None, Active=True\n        Key  : Active : Value\n        None :   True :   0.1\n\n  Constraints:\n    c : Size=1\n        Key  : Lower : Body : Upper\n        None :   1.0 :    1 :   1.0\n\n\n\nmodel.pprint()\n\n2 Var Declarations\n    x : Size=1, Index=None\n        Key  : Lower : Value : Upper : Fixed : Stale : Domain\n        None :  -1.2 :     0 :     2 : False : False :  Reals\n    y : Size=1, Index=None\n        Key  : Lower : Value : Upper : Fixed : Stale : Domain\n        None :   -10 :     1 :    10 : False : False :  Reals\n\n1 Objective Declarations\n    objective : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize : x + 0.1*y\n\n1 Constraint Declarations\n    c : Size=1, Index=None, Active=True\n        Key  : Lower : Body  : Upper : Active\n        None :   1.0 : x + y :   1.0 :   True\n\n2 Disjunct Declarations\n    fix_x : Size=1, Index=None, Active=True\n        1 Var Declarations\n            binary_indicator_var : Size=1, Index=None\n                Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                None :     0 :     1 :     1 : False : False : Binary\n\n        1 Constraint Declarations\n            c : Size=1, Index=None, Active=True\n                Key  : Lower : Body : Upper : Active\n                None :   0.0 :    x :   0.0 :   True\n\n        1 BooleanVar Declarations\n            indicator_var : Size=1, Index=None\n                Key  : Value : Fixed : Stale\n                None :  True : False : False\n\n        3 Declarations: indicator_var binary_indicator_var c\n    fix_y : Size=1, Index=None, Active=True\n        1 Var Declarations\n            binary_indicator_var : Size=1, Index=None\n                Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                None :     0 :     0 :     1 : False : False : Binary\n\n        1 Constraint Declarations\n            c : Size=1, Index=None, Active=True\n                Key  : Lower : Body : Upper : Active\n                None :   0.0 :    y :   0.0 :   True\n\n        1 BooleanVar Declarations\n            indicator_var : Size=1, Index=None\n                Key  : Value : Fixed : Stale\n                None : False : False : False\n\n        3 Declarations: indicator_var binary_indicator_var c\n\n1 Disjunction Declarations\n    d : Size=1, Index=None, Active=True\n        Key  : Disjuncts          : Active : XOR\n        None : ['fix_x', 'fix_y'] :   True : True\n\n7 Declarations: x y c fix_x fix_y d objective\n\n\n\nresults\n\n{'Problem': [{'Name': 'LOA example', 'Lower bound': 0.1, 'Upper bound': 0.1, 'Number of objectives': 1, 'Number of constraints': 3, 'Number of variables': 4, 'Number of binary variables': 2, 'Number of integer variables': 0, 'Number of continuous variables': 2, 'Number of nonzeros': None, 'Sense': 'minimize', 'Number of disjunctions': 1}], 'Solver': [{'Name': 'GDPopt (22, 5, 13) - LOA', 'Status': 'ok', 'User time': 0.0742967079859227, 'Wallclock time': 0.0742967079859227, 'Termination condition': 'optimal', 'Iterations': 1, 'Timing': Bunch(integer cut generation = 0.00014595797983929515, main_timer_start_time = 338634.26841425, mip = 0.06020570796681568, nlp = 0.008367584028746933, total = 0.0742967079859227)}]}\n\n\n\n# ── Pretty-print results ──────────────────────────────────────────────────────\nsep = \"─\" * 50\nprint(f\"\\n{'═'*50}\")\nprint(f\"  Solver Summary: {model.name}\")\nprint(f\"{'═'*50}\")\n# Solver metadata\nsolver_info = results.solver\nprint(f\"  Solver status   : {solver_info.status}\")\nprint(f\"  Termination cond: {solver_info.termination_condition}\")\nprint(sep)\n# Objective & decision variables\nprint(f\"  Objective value : {pyo.value(model.objective):.6f}\")\nprint(sep)\nprint(f\"  Decision Variables\")\nprint(f\"    x = {pyo.value(model.x):.6f}\")\nprint(f\"    y = {pyo.value(model.y):.6f}\")\nprint(sep)\n# Active disjunct\nactive = \"fix_x (x = 0)\" if pyo.value(model.fix_x.binary_indicator_var) &gt; 0.5 \\\n    else \"fix_y (y = 0)\"\nprint(f\"  Active disjunct : {active}\")\n\nprint(f\"{'═'*50}\\n\")\n\n\n══════════════════════════════════════════════════\n  Solver Summary: LOA example\n══════════════════════════════════════════════════\n  Solver status   : ok\n  Termination cond: optimal\n──────────────────────────────────────────────────\n  Objective value : 0.100000\n──────────────────────────────────────────────────\n  Decision Variables\n    x = 0.000000\n    y = 1.000000\n──────────────────────────────────────────────────\n  Active disjunct : fix_x (x = 0)\n══════════════════════════════════════════════════\n\n\n\n\nproblem_info = results.problem\n# Timing\nprint(sep)\nsolver_time = getattr(solver_info, 'user_time', None)\nwall_time   = getattr(solver_info, 'wallclock_time', None)\nprint(f\"  Timing\")\nprint(f\"    CPU time  : {solver_time:.4f} s\" if solver_time is not None else \"    CPU time  : n/a\")\nprint(f\"    Wall time : {wall_time:.4f} s\"   if wall_time  is not None else \"    Wall time : n/a\")\nprint(sep)\n# Problem size\nn_vars   = getattr(problem_info, 'number_of_variables',           None)\nn_bin    = getattr(problem_info, 'number_of_binary_variables',    None)\nn_cont   = getattr(problem_info, 'number_of_continuous_variables',None)\nn_cons   = getattr(problem_info, 'number_of_constraints',         None)\nprint(f\"  Problem Size\")\nprint(f\"    Variables   : {n_vars}\"  if n_vars is not None else \"    Variables   : n/a\")\nprint(f\"      Binary    : {n_bin}\"   if n_bin  is not None else \"      -Binary    : n/a\")\nprint(f\"      Continuous: {n_cont}\"  if n_cont is not None else \"      -Continuous: n/a\")\nprint(f\"    Constraints : {n_cons}\"  if n_cons is not None else \"    Constraints : n/a\")\nprint(sep)\n\n──────────────────────────────────────────────────\n  Timing\n    CPU time  : 0.0743 s\n    Wall time : 0.0743 s\n──────────────────────────────────────────────────\n  Problem Size\n    Variables   : 4\n      Binary    : 2\n      Continuous: 2\n    Constraints : 3\n──────────────────────────────────────────────────\n\n\n\nsolver_info()\n\n{'Name': 'GDPopt (22, 5, 13) - LOA', 'Status': 'ok', 'User time': 0.0742967079859227, 'Wallclock time': 0.0742967079859227, 'Termination condition': 'optimal', 'Iterations': 1, 'Timing': Bunch(integer cut generation = 0.00014595797983929515, main_timer_start_time = 338634.26841425, mip = 0.06020570796681568, nlp = 0.008367584028746933, total = 0.0742967079859227)}\n\n\n\nproblem_info()\n\n{'Name': 'LOA example', 'Lower bound': 0.1, 'Upper bound': 0.1, 'Number of objectives': 1, 'Number of constraints': 3, 'Number of variables': 4, 'Number of binary variables': 2, 'Number of integer variables': 0, 'Number of continuous variables': 2, 'Number of nonzeros': None, 'Sense': 'minimize', 'Number of disjunctions': 1}",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Example 3: GDPopt Test</span>"
    ]
  },
  {
    "objectID": "examples/01-Disjunctions.html",
    "href": "examples/01-Disjunctions.html",
    "title": "Example 1: Disjunctions - Theory, Examples",
    "section": "",
    "text": "Explanation\nThis is an illustrative notebook for disjunctive constraints in pyomo. We cover\nDisjunctions selectively enforce differing sets of constraints, for",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Example 1: Disjunctions - Theory, Examples</span>"
    ]
  },
  {
    "objectID": "examples/01-Disjunctions.html#explanation",
    "href": "examples/01-Disjunctions.html#explanation",
    "title": "Example 1: Disjunctions - Theory, Examples",
    "section": "",
    "text": "sequencing: \\(x\\) ends before \\(y,\\) or \\(y\\) ends before \\(x\\)\nswitching: a unit is built/used or not\nalternative selection: select from a set of pricing policies (or cost vs. performance)",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Example 1: Disjunctions - Theory, Examples</span>"
    ]
  },
  {
    "objectID": "examples/01-Disjunctions.html#disjunction-formulation",
    "href": "examples/01-Disjunctions.html#disjunction-formulation",
    "title": "Example 1: Disjunctions - Theory, Examples",
    "section": "Disjunction Formulation",
    "text": "Disjunction Formulation\nFollowing [Grossmann, 2021], the generalized disjunctive program (GDP) has the following formulation.\n\\[\\begin{equation}\n\\lor_{i \\in D_{k}}\n\\begin{bmatrix}\nY_{ik}\\\\\nn_{ik}(x)\\leq0\\\\\nc_{k} = \\mu_{ik}\n\\end{bmatrix} \\ \\ \\ , \\ \\ \\ \\Omega(Y)= \\text{True}\n\\end{equation}\\] where,\n\n\n\n\n\n\n\nNotation\nDefinition\n\n\n\n\n\\(\\lor\\)\nThe OR operator that connects a finite collection of disjunctive clauses\n\n\n\\(D_{k}\\)\nThe set of disjunctive terms\n\n\n\\(Y_{ik}\\)\nBoolean “indicator variable”\n\n\n\\(h_{ik}(x)\\leq 0\\)\nConstraint enforced when \\(Y_{ik}\\) is true\n\n\n\\(c_k = \\mu_{ik}\\)\nParameter values set when indicator variable is true\n\n\n\\(\\Omega(Y)\\)\nAdditional logical constraints on indicator variables (ensures XOR)",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Example 1: Disjunctions - Theory, Examples</span>"
    ]
  },
  {
    "objectID": "examples/01-Disjunctions.html#disjunctive-problem-formulation",
    "href": "examples/01-Disjunctions.html#disjunctive-problem-formulation",
    "title": "Example 1: Disjunctions - Theory, Examples",
    "section": "Disjunctive Problem Formulation",
    "text": "Disjunctive Problem Formulation\n\\[\\begin{equation*}  \\tag {01}\n\\begin{array}{llr}\n\\textrm{min} & f(x)                      & \\textrm{Objective Function}    \\\\\n\\textrm{s.t.} &       g(x) \\, \\leq \\, 0  & \\textrm{Algebraic Constraints}  \\\\\n& \\bigvee_{i \\in D_k} \\begin{bmatrix}\n  Y_{ik}  \\\\\n  r_{ik}(x) \\leq 0\n\\end{bmatrix}, \\, k \\in K & \\textrm{Disjunctions}\n\\\\\n& \\Omega (Y) = \\textrm{True} & \\textrm{Logic Propositions} \\\\\n& L \\leq x \\leq U, \\, x  \\in \\mathbb R^n,   & \\textrm{Continuous Variables} \\\\\n& Y_{ik}   \\in  \\{\\textrm{True, False} \\}   & \\textrm{Boolean Variables}\n\\end{array}\n\\end{equation*}\\]\nwhere,\n\n\\(f : \\mathbb R^n \\rightarrow \\mathbb R\\) is a function, \\(x\\) is a vector of continuous variables with bounds \\(L\\) and \\(U\\)\n\\(g : \\mathbb R^n \\rightarrow \\mathbb R^l\\) represents the set of global constraints.\nEach disjunction \\(k \\in K\\) is composed of a number of terms \\(i \\in D_k\\) that are connected by the Boolean operator OR (\\(\\vee\\) ).\nEach term \\(i \\in D_k\\) consists of a Boolean variable \\(Y_{ik}\\) and a set of inequalities \\(r_{ik}(x) \\leq 0,\\) where \\(r_{ik} : \\mathbb R^n \\rightarrow \\mathbb R^j.\\) If \\(Y_{ik}\\) is true, then \\(r_{ik}(x) \\leq 0\\) is enforced, otherwise these constraints are ignored.\n\\(\\Omega (Y) = \\textrm{True}\\) are logic propositions for the Boolean variables \\(Y_{ik},\\) where for each clause \\(t \\in {1, \\dots, T},\\) the set \\(R_t\\) is the subset of Boolean variables that are non-negated and \\(Q_t\\) is the subset of Boolean variables that are negated.\n\nN.B.: we assume that each disjunction is an exclusive-or, so that for each \\(k\\) exactly one variable \\(Y_{ik}\\) is true. Put another way, we assume the logic constraints \\(\\underline{\\vee}_{i \\in D_k} Y_{ik}\\) are contained in \\(\\Omega (Y) = \\textrm{True}.\\)",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Example 1: Disjunctions - Theory, Examples</span>"
    ]
  },
  {
    "objectID": "examples/01-Disjunctions.html#example-1-facility-choice",
    "href": "examples/01-Disjunctions.html#example-1-facility-choice",
    "title": "Example 1: Disjunctions - Theory, Examples",
    "section": "Example 1: Facility choice",
    "text": "Example 1: Facility choice\nThis (trivial) disjunction example involves selecting between two facilities to minimize the power \\(P:\\)\n\nIf facility 1 is selected, then power \\(P\\) is between \\(5\\) and \\(10\\) units.\nIf facility 2 is selected, then power \\(P\\) is between \\(20\\) and \\(30\\) units.\n\nLinear Disjunction Form: \\[\n\\begin{equation}\n\\lor_{i \\in D}\n\\begin{bmatrix}\nA_{i}x \\leq b_{i}(x)\n\\end{bmatrix}\n\\end{equation}\\]\nApplied to the Facility-choice Problem: \\[\n\\begin{equation}\n  \\begin{bmatrix}\n    y_1\\\\\n    P \\leq 10\\\\\n    -P \\leq -5\n  \\end{bmatrix} \\lor\n  \\begin{bmatrix}\n    y_2\\\\\n    P \\leq 30\\\\\n    -P \\leq -20\n  \\end{bmatrix}\n\\end{equation}\\]\nwhere the Boolean (binary) variable \\(y_{1}\\) represents facility 1 and \\(y_{2}\\) represents facility 2.\n\nDefine Model in pyomo with GDP\nUse the disjunctionconstuct of pyomo to define the facility-choice problem.\n\nimport pyomo.environ as pyo\n\ndef create_model():\n    '''\n    Build the facility problem model.\n    \n    Return:\n    model: Pyomo model\n    '''\n    ## Model\n    model = pyo.ConcreteModel(name=\"Selecting a facility\")\n\n    ## Sets\n    # Initialized for facility 1 (1) and facility 2 (2)\n    model.facilities = pyo.Set(initialize=[1,2])\n\n    ## Parameters\n    # Initialized with a dictionary where the keys are 1 and 2 (the facilities)\n    # for the minimum and maximum power values\n    model.min_power = pyo.Param(model.facilities,initialize={1:5,2:20}) \n    model.max_power = pyo.Param(model.facilities,initialize={1:10,2:30})\n    \n    ## Variables\n    # Facility power bounded between the lower bound (5) and upper bound (30)\n    model.P = pyo.Var(bounds=(5,30),doc='Facilty power')\n\n    ## Adding an objective for the example\n    @model.Objective()\n    def objective(model):\n      return model.P \n\n    ## Disjunctions\n    \n    # Objective is bounded by the maximum and minimum power values\n    @model.Disjunction(#xor=True,\n        model.facilities,\n        doc=\"Power bounds for different facility selections\")\n    def power_bounds(m, r):\n        return [\n            m.P &lt;= m.max_power[r],\n            m.P &gt;= m.min_power[r],\n        ]\n\n    return model\n\n\n\nBig-M Relaxation Approach\nWe use “Big-M” constraints to convert the linear disjunctions into mixed-integer constraints to represent logic with continuous variables. The Big-M reformulation results in a smaller transformed model, avoiding the need to add extra variables; however, it yields a looser continuous relaxation. By default, the Big-M transformation will estimate reasonably tight M values if variables are bounded.\nThe basic idea in the big-M constraints is that for \\(y_j = 1,\\) the inequality holds true, i.e., \\(A_j x \\le  b_j.\\) In contrast, when \\(y_j = 0,\\) the inequality becomes redundant for a sufficiently large parameter because then \\(A_j x \\le b_j + M_j.\\) Clearly the value of \\(M_j\\) has to be carefully chosen. A large value will help to render the linear inequality to be redundant. On the other hand, a large value will also cause the LP relaxation to be weak.\nGeneral Notation:\n\\[\\begin{equation}\nA_{i}(x) \\leq b_{i} + M_{i}(1-y_{i})  \\ , \\  \\forall i \\in D\n\\end{equation}\\]\n\\[\\begin{equation}\n\\sum_{i \\in D} y_{i} = 1\n\\end{equation}\\]\n\\[\\begin{equation}\ny_{i} \\in \\{0,1\\} \\ , \\  \\forall i \\in D\n\\end{equation}\\]\nApplied to the Facility Problem: \\[\n\\begin{align}\n  P &\\leq 10 + M_{1}(1-y_{1})\\\\\n  -P &\\leq -5 + M_{1}(1-y_{1})\\\\\n  P &\\leq 30 + M_{2}(1-y_{2})\\\\\n  -P &\\leq -20 + M_{2}(1-y_{2})\\\\\n  &y_{1} + y_{2} = 1\n\\end{align}\\]\nWhen the \\(y\\)’s are considered continuous variables, weak bounds for the objective function are formed for large values such as: \\[\nM_{1} = 100 \\ \\ \\text{and} \\ \\ M_{2} = 100\\]\nMain Idea:  Considering the special case where \\(h_{i}(x) = A_{i}x - b_{i} \\leq 0,\\) \\(M_{i}\\) is sufficiently large to relax \\(h_{i}(x) \\leq 0\\) when \\(y_{i}=0\\)\nKey Takeaways:\n\nIf \\(M\\) is too large, we can get a “weak relaxation” because integer programming algorithms need more iterations.\nIf \\(M\\) is too small, we can get unintended bounds.\n\nBig-M is best to use if the problem size is small.\n\n\nBig-M Implementation in Pyomo\nFirst create and print the model.\n\n# Creating the model\nmodel = create_model()\n\n# Printing the model\nmodel.pprint()\n\n1 Set Declarations\n    facilities : Size=1, Index=None, Ordered=Insertion\n        Key  : Dimen : Domain : Size : Members\n        None :     1 :    Any :    2 : {1, 2}\n\n2 Param Declarations\n    max_power : Size=2, Index=facilities, Domain=Any, Default=None, Mutable=False\n        Key : Value\n          1 :    10\n          2 :    30\n    min_power : Size=2, Index=facilities, Domain=Any, Default=None, Mutable=False\n        Key : Value\n          1 :     5\n          2 :    20\n\n1 Var Declarations\n    P : Facilty power\n        Size=1, Index=None\n        Key  : Lower : Value : Upper : Fixed : Stale : Domain\n        None :     5 :  None :    30 : False :  True :  Reals\n\n1 Objective Declarations\n    objective : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize :          P\n\n1 Disjunct Declarations\n    power_bounds_disjuncts : Size=4, Index=Any, Active=True\n        power_bounds_disjuncts[0] : Active=True\n            1 Var Declarations\n                binary_indicator_var : Size=1, Index=None\n                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                    None :     0 :  None :     1 : False :  True : Binary\n\n            1 Constraint Declarations\n                constraint : Size=1, Index={1}, Active=True\n                    Key : Lower : Body : Upper : Active\n                      1 :  -Inf :    P :  10.0 :   True\n\n            1 BooleanVar Declarations\n                indicator_var : Size=1, Index=None\n                    Key  : Value : Fixed : Stale\n                    None :  None : False :  True\n\n            1 LogicalConstraint Declarations\n                propositions : Size=0, Index={}, Active=True\n                    Key : Body : Active\n\n            4 Declarations: indicator_var binary_indicator_var constraint propositions\n        power_bounds_disjuncts[1] : Active=True\n            1 Var Declarations\n                binary_indicator_var : Size=1, Index=None\n                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                    None :     0 :  None :     1 : False :  True : Binary\n\n            1 Constraint Declarations\n                constraint : Size=1, Index={1}, Active=True\n                    Key : Lower : Body : Upper : Active\n                      1 :   5.0 :    P :  +Inf :   True\n\n            1 BooleanVar Declarations\n                indicator_var : Size=1, Index=None\n                    Key  : Value : Fixed : Stale\n                    None :  None : False :  True\n\n            1 LogicalConstraint Declarations\n                propositions : Size=0, Index={}, Active=True\n                    Key : Body : Active\n\n            4 Declarations: indicator_var binary_indicator_var constraint propositions\n        power_bounds_disjuncts[2] : Active=True\n            1 Var Declarations\n                binary_indicator_var : Size=1, Index=None\n                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                    None :     0 :  None :     1 : False :  True : Binary\n\n            1 Constraint Declarations\n                constraint : Size=1, Index={1}, Active=True\n                    Key : Lower : Body : Upper : Active\n                      1 :  -Inf :    P :  30.0 :   True\n\n            1 BooleanVar Declarations\n                indicator_var : Size=1, Index=None\n                    Key  : Value : Fixed : Stale\n                    None :  None : False :  True\n\n            1 LogicalConstraint Declarations\n                propositions : Size=0, Index={}, Active=True\n                    Key : Body : Active\n\n            4 Declarations: indicator_var binary_indicator_var constraint propositions\n        power_bounds_disjuncts[3] : Active=True\n            1 Var Declarations\n                binary_indicator_var : Size=1, Index=None\n                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                    None :     0 :  None :     1 : False :  True : Binary\n\n            1 Constraint Declarations\n                constraint : Size=1, Index={1}, Active=True\n                    Key : Lower : Body : Upper : Active\n                      1 :  20.0 :    P :  +Inf :   True\n\n            1 BooleanVar Declarations\n                indicator_var : Size=1, Index=None\n                    Key  : Value : Fixed : Stale\n                    None :  None : False :  True\n\n            1 LogicalConstraint Declarations\n                propositions : Size=0, Index={}, Active=True\n                    Key : Body : Active\n\n            4 Declarations: indicator_var binary_indicator_var constraint propositions\n\n1 Disjunction Declarations\n    power_bounds : Power bounds for different facility selections\n        Size=2, Index=facilities, Active=True\n        Key : Disjuncts                                                  : Active : XOR\n          1 : ['power_bounds_disjuncts[0]', 'power_bounds_disjuncts[1]'] :   True : True\n          2 : ['power_bounds_disjuncts[2]', 'power_bounds_disjuncts[3]'] :   True : True\n\n7 Declarations: facilities min_power max_power P objective power_bounds power_bounds_disjuncts\n\n\n\n# Applying Big-M relaxation to the model\npyo.TransformationFactory('gdp.bigm').apply_to(model)\n\n# Printing\nmodel.pprint()\n\n1 Set Declarations\n    facilities : Size=1, Index=None, Ordered=Insertion\n        Key  : Dimen : Domain : Size : Members\n        None :     1 :    Any :    2 : {1, 2}\n\n2 Param Declarations\n    max_power : Size=2, Index=facilities, Domain=Any, Default=None, Mutable=False\n        Key : Value\n          1 :    10\n          2 :    30\n    min_power : Size=2, Index=facilities, Domain=Any, Default=None, Mutable=False\n        Key : Value\n          1 :     5\n          2 :    20\n\n1 Var Declarations\n    P : Facilty power\n        Size=1, Index=None\n        Key  : Lower : Value : Upper : Fixed : Stale : Domain\n        None :     5 :  None :    30 : False :  True :  Reals\n\n1 Objective Declarations\n    objective : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize :          P\n\n1 Block Declarations\n    _pyomo_gdp_bigm_reformulation : Size=1, Index=None, Active=True\n        1 Constraint Declarations\n            power_bounds_xor : Size=2, Index=Any, Active=True\n                Key : Lower : Body                                                                                            : Upper : Active\n                  1 :   1.0 : power_bounds_disjuncts[0].binary_indicator_var + power_bounds_disjuncts[1].binary_indicator_var :   1.0 :   True\n                  2 :   1.0 : power_bounds_disjuncts[2].binary_indicator_var + power_bounds_disjuncts[3].binary_indicator_var :   1.0 :   True\n\n        1 Block Declarations\n            relaxedDisjuncts : Size=4, Index=NonNegativeIntegers, Active=True\n                _pyomo_gdp_bigm_reformulation.relaxedDisjuncts[0] : Active=True\n                    1 Constraint Declarations\n                        transformedConstraints : Size=1, Index=Any, Active=True\n                            Key                          : Lower : Body                                                          : Upper : Active\n                            ('constraint[1]_0', 1, 'ub') :  -Inf : P - 20.0*(1 - power_bounds_disjuncts[0].binary_indicator_var) :  10.0 :   True\n\n                    1 Block Declarations\n                        localVarReferences : Size=1, Index=None, Active=True\n                            1 Var Declarations\n                                binary_indicator_var : Size=1, Index=UnindexedComponent_ReferenceSet, ReferenceTo=power_bounds_disjuncts[0].binary_indicator_var\n                                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                                    None :     0 :  None :     1 : False :  True : Binary\n\n                            1 Declarations: binary_indicator_var\n\n                    2 Declarations: transformedConstraints localVarReferences\n                _pyomo_gdp_bigm_reformulation.relaxedDisjuncts[1] : Active=True\n                    1 Constraint Declarations\n                        transformedConstraints : Size=1, Index=Any, Active=True\n                            Key                          : Lower : Body                                                         : Upper : Active\n                            ('constraint[1]_0', 1, 'lb') :   5.0 : P - 0.0*(1 - power_bounds_disjuncts[1].binary_indicator_var) :  +Inf :   True\n\n                    1 Block Declarations\n                        localVarReferences : Size=1, Index=None, Active=True\n                            1 Var Declarations\n                                binary_indicator_var : Size=1, Index=UnindexedComponent_ReferenceSet, ReferenceTo=power_bounds_disjuncts[1].binary_indicator_var\n                                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                                    None :     0 :  None :     1 : False :  True : Binary\n\n                            1 Declarations: binary_indicator_var\n\n                    2 Declarations: transformedConstraints localVarReferences\n                _pyomo_gdp_bigm_reformulation.relaxedDisjuncts[2] : Active=True\n                    1 Constraint Declarations\n                        transformedConstraints : Size=1, Index=Any, Active=True\n                            Key                          : Lower : Body                                                         : Upper : Active\n                            ('constraint[1]_0', 1, 'ub') :  -Inf : P - 0.0*(1 - power_bounds_disjuncts[2].binary_indicator_var) :  30.0 :   True\n\n                    1 Block Declarations\n                        localVarReferences : Size=1, Index=None, Active=True\n                            1 Var Declarations\n                                binary_indicator_var : Size=1, Index=UnindexedComponent_ReferenceSet, ReferenceTo=power_bounds_disjuncts[2].binary_indicator_var\n                                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                                    None :     0 :  None :     1 : False :  True : Binary\n\n                            1 Declarations: binary_indicator_var\n\n                    2 Declarations: transformedConstraints localVarReferences\n                _pyomo_gdp_bigm_reformulation.relaxedDisjuncts[3] : Active=True\n                    1 Constraint Declarations\n                        transformedConstraints : Size=1, Index=Any, Active=True\n                            Key                          : Lower : Body                                                          : Upper : Active\n                            ('constraint[1]_0', 1, 'lb') :  20.0 : P + 15.0*(1 - power_bounds_disjuncts[3].binary_indicator_var) :  +Inf :   True\n\n                    1 Block Declarations\n                        localVarReferences : Size=1, Index=None, Active=True\n                            1 Var Declarations\n                                binary_indicator_var : Size=1, Index=UnindexedComponent_ReferenceSet, ReferenceTo=power_bounds_disjuncts[3].binary_indicator_var\n                                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                                    None :     0 :  None :     1 : False :  True : Binary\n\n                            1 Declarations: binary_indicator_var\n\n                    2 Declarations: transformedConstraints localVarReferences\n\n        2 Declarations: relaxedDisjuncts power_bounds_xor\n\n1 Disjunct Declarations\n    power_bounds_disjuncts : Size=4, Index=Any, Active=False\n        power_bounds_disjuncts[0] : Active=False\n            1 Var Declarations\n                binary_indicator_var : Size=1, Index=None\n                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                    None :     0 :  None :     1 : False :  True : Binary\n\n            1 Constraint Declarations\n                constraint : Size=1, Index={1}, Active=True\n                    Key : Lower : Body : Upper : Active\n                      1 :  -Inf :    P :  10.0 :  False\n\n            1 BooleanVar Declarations\n                indicator_var : Size=1, Index=None\n                    Key  : Value : Fixed : Stale\n                    None :  None : False :  True\n\n            1 LogicalConstraint Declarations\n                propositions : Size=0, Index={}, Active=False\n                    Key : Body : Active\n\n            4 Declarations: indicator_var binary_indicator_var constraint propositions\n        power_bounds_disjuncts[1] : Active=False\n            1 Var Declarations\n                binary_indicator_var : Size=1, Index=None\n                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                    None :     0 :  None :     1 : False :  True : Binary\n\n            1 Constraint Declarations\n                constraint : Size=1, Index={1}, Active=True\n                    Key : Lower : Body : Upper : Active\n                      1 :   5.0 :    P :  +Inf :  False\n\n            1 BooleanVar Declarations\n                indicator_var : Size=1, Index=None\n                    Key  : Value : Fixed : Stale\n                    None :  None : False :  True\n\n            1 LogicalConstraint Declarations\n                propositions : Size=0, Index={}, Active=False\n                    Key : Body : Active\n\n            4 Declarations: indicator_var binary_indicator_var constraint propositions\n        power_bounds_disjuncts[2] : Active=False\n            1 Var Declarations\n                binary_indicator_var : Size=1, Index=None\n                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                    None :     0 :  None :     1 : False :  True : Binary\n\n            1 Constraint Declarations\n                constraint : Size=1, Index={1}, Active=True\n                    Key : Lower : Body : Upper : Active\n                      1 :  -Inf :    P :  30.0 :  False\n\n            1 BooleanVar Declarations\n                indicator_var : Size=1, Index=None\n                    Key  : Value : Fixed : Stale\n                    None :  None : False :  True\n\n            1 LogicalConstraint Declarations\n                propositions : Size=0, Index={}, Active=False\n                    Key : Body : Active\n\n            4 Declarations: indicator_var binary_indicator_var constraint propositions\n        power_bounds_disjuncts[3] : Active=False\n            1 Var Declarations\n                binary_indicator_var : Size=1, Index=None\n                    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n                    None :     0 :  None :     1 : False :  True : Binary\n\n            1 Constraint Declarations\n                constraint : Size=1, Index={1}, Active=True\n                    Key : Lower : Body : Upper : Active\n                      1 :  20.0 :    P :  +Inf :  False\n\n            1 BooleanVar Declarations\n                indicator_var : Size=1, Index=None\n                    Key  : Value : Fixed : Stale\n                    None :  None : False :  True\n\n            1 LogicalConstraint Declarations\n                propositions : Size=0, Index={}, Active=False\n                    Key : Body : Active\n\n            4 Declarations: indicator_var binary_indicator_var constraint propositions\n\n1 Disjunction Declarations\n    power_bounds : Power bounds for different facility selections\n        Size=2, Index=facilities, Active=False\n        Key : Disjuncts                                                  : Active : XOR\n          1 : ['power_bounds_disjuncts[0]', 'power_bounds_disjuncts[1]'] :  False : True\n          2 : ['power_bounds_disjuncts[2]', 'power_bounds_disjuncts[3]'] :  False : True\n\n8 Declarations: facilities min_power max_power P objective power_bounds power_bounds_disjuncts _pyomo_gdp_bigm_reformulation\n\n\n\n# Solve and print the solution\npyo.SolverFactory('cbc').solve(model, tee=True)\n\nmodel.P.display()\n\nWelcome to the CBC MILP Solver \nVersion: 2.10.12 \nBuild Date: Mar  5 2025 \n\ncommand line - /opt/miniconda3/envs/exa-atow/bin/cbc -printingOptions all -import /var/folders/kx/_1g1vzv51nq1yv81c377flsr0000gn/T/tmpu2hntyxq.pyomo.lp -stat=1 -solve -solu /var/folders/kx/_1g1vzv51nq1yv81c377flsr0000gn/T/tmpu2hntyxq.pyomo.soln (default strategy 1)\nOption for printingOptions changed from normal to all\nPresolve 0 (-6) rows, 0 (-5) columns and 0 (-10) elements\nStatistics for presolved model\nOriginal problem has 4 integers (4 of which binary)\n\n\nProblem has 0 rows, 0 columns (0 with objective) and 0 elements\nColumn breakdown:\n0 of type 0.0-&gt;inf, 0 of type 0.0-&gt;up, 0 of type lo-&gt;inf, \n0 of type lo-&gt;up, 0 of type free, 0 of type fixed, \n0 of type -inf-&gt;0.0, 0 of type -inf-&gt;up, 0 of type 0.0-&gt;1.0 \nRow breakdown:\n0 of type E 0.0, 0 of type E 1.0, 0 of type E -1.0, \n0 of type E other, 0 of type G 0.0, 0 of type G 1.0, \n0 of type G other, 0 of type L 0.0, 0 of type L 1.0, \n0 of type L other, 0 of type Range 0.0-&gt;1.0, 0 of type Range other, \n0 of type Free \nContinuous objective value is 5 - 0.00 seconds\nCgl0004I processed model has 0 rows, 0 columns (0 integer (0 of which binary)) and 0 elements\nCbc3007W No integer variables - nothing to do\nCuts at root node changed objective from 5 to -1.79769e+308\nProbing was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nGomory was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nKnapsack was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nClique was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nMixedIntegerRounding2 was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nFlowCover was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nTwoMirCuts was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nZeroHalf was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n\nResult - Optimal solution found\n\nObjective value:                5.00000000\nEnumerated nodes:               0\nTotal iterations:               0\nTime (CPU seconds):             0.00\nTime (Wallclock seconds):       0.00\n\nTotal time (CPU seconds):       0.00   (Wallclock seconds):       0.01\n\nP : Facilty power\n    Size=1, Index=None\n    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n    None :     5 :   5.0 :    30 : False : False :  Reals\n\n\n\n\nConvex hull approach\nConvex hull can be used if we do not want to implement Big-M parameters. This approach requires separating the continuous variables into its components.\nGeneral Notation:\n\\[\n\\begin{equation}\nx = \\sum_{i \\in D} z_{i}\n\\end{equation}\n\\]\n\\[\n\\begin{equation}\nA_{i} z_{i} \\leq b_{i}y_{i}  \\ , \\ \\forall i \\in D\n\\end{equation}\n\\]\n\\[\n\\begin{equation}\n\\sum_{i \\in D} y_{i} = 1\n\\end{equation}\n\\]\n\\[\n\\begin{equation}\n0 \\leq z_{i} \\leq Uy_{i}  \\ , \\ \\forall i \\in D\n\\end{equation}\n\\]\n\\[\n\\begin{equation}\ny_{i} = \\{0,1\\} \\ , \\ \\forall i \\in D\n\\end{equation}\n\\]\nwhere \\(z_{i}\\) are continuous variables separated into as many new variables as there are terms for the disjunctions.\nApplied to the Facility Problem:\n\\[\n\\begin{align}\n  P &= P_{1} + P_{2} \\\\\n  P_{1} &\\leq 10y_{1}\\\\\n  P_{2} &\\leq 30y_{2} \\\\\n  -P_{1} &\\leq -5y_{1}\\\\\n  -P_{2} &\\leq -20y_{2}\\\\\n  &y_{1} + y_{2} = 1\n\\end{align}\\]\nKey Takeaways:\n(+) Constraints do not require Big-M parameters which produce a tight linear programming relaxation.  (–) A larger number of variables and constraints is required.\nConvex hull is better to use than Big-M if the problem is large.\n\n# Creating the model\nmodel = create_model()\n\n# Apply convex hull relaxation to the model\npyo.TransformationFactory('gdp.hull').apply_to(model)\n\n# Solve and print the solution\npyo.SolverFactory('cbc').solve(model, tee=True)\n\nmodel.P.display()\n\nWelcome to the CBC MILP Solver \nVersion: 2.10.12 \nBuild Date: Mar  5 2025 \n\ncommand line - /opt/miniconda3/envs/exa-atow/bin/cbc -printingOptions all -import /var/folders/kx/_1g1vzv51nq1yv81c377flsr0000gn/T/tmp1bjx2j8r.pyomo.lp -stat=1 -solve -solu /var/folders/kx/_1g1vzv51nq1yv81c377flsr0000gn/T/tmp1bjx2j8r.pyomo.soln (default strategy 1)\nOption for printingOptions changed from normal to all\nPresolve 10 (-6) rows, 5 (-4) columns and 24 (-10) elements\nStatistics for presolved model\nOriginal problem has 4 integers (4 of which binary)\nPresolved problem has 2 integers (2 of which binary)\n==== 4 zero objective 2 different\n4 variables have objective of 0\n1 variables have objective of 1\n==== absolute objective values 2 different\n4 variables have objective of 0\n1 variables have objective of 1\n==== for integers 2 zero objective 1 different\n2 variables have objective of 0\n==== for integers absolute objective values 1 different\n2 variables have objective of 0\n===== end objective counts\n\n\nProblem has 10 rows, 5 columns (1 with objective) and 24 elements\nColumn breakdown:\n0 of type 0.0-&gt;inf, 2 of type 0.0-&gt;up, 0 of type lo-&gt;inf, \n1 of type lo-&gt;up, 0 of type free, 0 of type fixed, \n0 of type -inf-&gt;0.0, 0 of type -inf-&gt;up, 2 of type 0.0-&gt;1.0 \nRow breakdown:\n0 of type E 0.0, 0 of type E 1.0, 0 of type E -1.0, \n0 of type E other, 0 of type G 0.0, 0 of type G 1.0, \n0 of type G other, 5 of type L 0.0, 0 of type L 1.0, \n5 of type L other, 0 of type Range 0.0-&gt;1.0, 0 of type Range other, \n0 of type Free \nContinuous objective value is 5 - 0.00 seconds\nCgl0003I 0 fixed, 0 tightened bounds, 1 strengthened rows, 0 substitutions\nCgl0003I 0 fixed, 0 tightened bounds, 1 strengthened rows, 0 substitutions\nCgl0004I processed model has 8 rows, 5 columns (2 integer (2 of which binary)) and 21 elements\nCbc0038I Initial state - 0 integers unsatisfied sum - 0\nCbc0038I Solution found of 5\nCbc0038I Relaxing continuous gives 5\nCbc0038I Before mini branch and bound, 2 integers at bound fixed and 3 continuous\nCbc0038I Mini branch and bound did not improve solution (0.00 seconds)\nCbc0038I After 0.00 seconds - Feasibility pump exiting with objective of 5 - took 0.00 seconds\nCbc0012I Integer solution of 5 found by feasibility pump after 0 iterations and 0 nodes (0.00 seconds)\nCbc0001I Search completed - best objective 5, took 0 iterations and 0 nodes (0.00 seconds)\nCbc0035I Maximum depth 0, 0 variables fixed on reduced cost\nCuts at root node changed objective from 5 to 5\nProbing was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nGomory was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nKnapsack was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nClique was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nMixedIntegerRounding2 was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nFlowCover was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nTwoMirCuts was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nZeroHalf was tried 0 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n\nResult - Optimal solution found\n\nObjective value:                5.00000000\nEnumerated nodes:               0\nTotal iterations:               0\nTime (CPU seconds):             0.00\nTime (Wallclock seconds):       0.00\n\nTotal time (CPU seconds):       0.00   (Wallclock seconds):       0.01\n\nP : Facilty power\n    Size=1, Index=None\n    Key  : Lower : Value : Upper : Fixed : Stale : Domain\n    None :     5 :   5.0 :    30 : False : False :  Reals",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Example 1: Disjunctions - Theory, Examples</span>"
    ]
  },
  {
    "objectID": "examples/01-Disjunctions.html#example-2-production-technology-choice",
    "href": "examples/01-Disjunctions.html#example-2-production-technology-choice",
    "title": "Example 1: Disjunctions - Theory, Examples",
    "section": "Example 2: Production Technology Choice",
    "text": "Example 2: Production Technology Choice\nSuppose we have a choice between 2 technologies for production:\n\nTechnology 1: more time, less expensive.\nTechnology 2: less time, more expensive.",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Example 1: Disjunctions - Theory, Examples</span>"
    ]
  },
  {
    "objectID": "examples/01-Disjunctions.html#multi-product-factory-optimization",
    "href": "examples/01-Disjunctions.html#multi-product-factory-optimization",
    "title": "Example 1: Disjunctions - Theory, Examples",
    "section": "Multi-product factory optimization",
    "text": "Multi-product factory optimization\nA small production facility produces two products, \\(X\\) and \\(Y\\). With current technology \\(\\alpha\\), the facility is subject to the following conditions and constraints:\n\n\n\nProduct\nlabor A\nlabor B\nmaterial\nsales price\nprofit\n\n\n\n\nX\n1h\n2h\n100€\n270€\n40€\n\n\nY\n1h\n1h\n90€\n210€\n30€\n\n\n\n\nProduct \\(X\\) requires 1 hour of labor A, 2 hours of labor B, and 100€ of raw material. Product \\(X\\) sells for 270€ per unit. The daily demand is limited to 40 units.\nProduct \\(Y\\) requires 1 hour of labor A, 1 hour of labor B, and 90€ of raw material. Product \\(Y\\) sells for 210€ per unit with unlimited demand.\nThere are 80 hours per day of labor A available at a cost of 50 €/hour, and there are 100 hours per day of labor B available at a cost of 40 €/hour.\n\nUsing the given data we see that the net profit for each unit of \\(X\\) and \\(Y\\) is \\[\nP_X = 270 - (1 \\cdot 50 + 2 \\cdot 40) - 100  = 40\\] and \\[\nP_Y = 210 - (1 \\cdot 50 + 1 \\cdot 40 )- 90  = 30\\] respectively. The optimal product strategy is the solution of a linear optimization problem,\n\\[\n\\begin{align*}\n\\max \\quad & 40 x + 30 y\\\\\n\\text{s.t.} \\quad\n& x  \\leq 40 & \\text{(demand)}\\\\\n& x + y  \\leq 80 & \\text{(labor A)} \\\\\n& 2 x + y  \\leq 100 & \\text{(labor B)}\\\\\n& x, y \\geq 0.\n\\end{align*}\n\\]\n\nimport pyomo.environ as pyo\n\nsolver = 'appsi_highs'\nSOLVER = pyo.SolverFactory(solver)\n\nm = pyo.ConcreteModel(\"Multi-Product Factory\")\n\nm.production_x = pyo.Var(domain=pyo.NonNegativeReals)\nm.production_y = pyo.Var(domain=pyo.NonNegativeReals)\n\n@m.Objective(sense=pyo.maximize)\ndef maximize_profit(m):\n    return 40 * m.production_x + 30 * m.production_y\n\n@m.Constraint()\ndef demand(m):\n    return m.production_x &lt;= 40\n\n@m.Constraint()\ndef laborA(m):\n    return m.production_x + m.production_y &lt;= 80\n\n@m.Constraint()\ndef laborB(m):\n    return 2 * m.production_x + m.production_y &lt;= 100\n\nSOLVER.solve(m)\n\nprint(f\"Profit = ${pyo.value(m.maximize_profit):.2f}\")\nprint(f\"Production X = {pyo.value(m.production_x)}\")\nprint(f\"Production Y = {pyo.value(m.production_y)}\")\n\nProfit = $2600.00\nProduction X = 20.0\nProduction Y = 60.0\n\n\n\nDisjunction: technology choice\nSuppose a new technology \\(\\beta\\) has been developed for labor B, with the potential to cut costs by reducing the time required to finish product \\(X\\) from \\(2.0\\) to \\(1.5\\) hours, but requires more highly skilled labor with a higher unit cost of \\(50\\)€ per hour.\nThe net profit for unit of product \\(X\\)\n\nwith technology \\(\\alpha\\) is \\(270 - 100 - 50 - 2 \\cdot 40 = 40\\)€,\nwhile with technology \\(\\beta\\) is equal to \\(270 - 100 - 50 - 1.5 \\cdot 50 = 45\\)€.\n\nWe need to assess whether the new technology is beneficial, that is, whether adopting it would lead to higher profits. The decision here is whether to use technology \\(\\alpha\\) or \\(\\beta\\).\nIn this situation we have an `either-or’ structure for both the objective and for Labor B constraint:\n\\[\n\\underbrace{p = 40x + 30y, \\ 2 x + y \\leq 100}_{\\text{$\\alpha$ technology}} \\quad \\text{ or }  \\quad \\underbrace{p = 50x + 30y, \\ 1.5 x + y \\leq 100}_{\\text{$\\beta$ technology}}.\n\\]\nWe use two techniques for embedding disjunctions into mixed-integer linear optimization problems:\n\nBig-M\nConvex hull",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Example 1: Disjunctions - Theory, Examples</span>"
    ]
  },
  {
    "objectID": "examples/01-Disjunctions.html#big-m-implementation",
    "href": "examples/01-Disjunctions.html#big-m-implementation",
    "title": "Example 1: Disjunctions - Theory, Examples",
    "section": "Big-M implementation",
    "text": "Big-M implementation\nThe first approach is using the “big-M” technique introduces a single binary decision variable \\(z\\) associated with choosing technology \\(\\alpha\\) (\\(z=0\\)) or technology \\(\\beta\\) (\\(z=1\\)). Using MILP, we can formulate this problem as follows:\n\\[\n\\begin{align*}\n    \\max \\quad & \\text{profit}\\\\\n    \\text{s.t.} \\quad\n    & x  \\leq 40 & \\text{(demand)}\\\\\n    & x + y  \\leq 80 & \\text{(labor A)} \\\\\n    & \\text{profit} \\leq 40x + 30y + M z & \\text{(profit with technology $\\alpha$)} \\\\\n    & \\text{profit} \\leq 45x + 30y + M (1 - z) & \\text{(profit with technology $\\beta$)}\\\\\n    & 2 x + y \\leq 100  + M z & \\text{(labor B with technology $\\alpha$)} \\\\\n    & 1.5 x + y \\leq 100 + M (1 - z) & \\text{(labor B with technology $\\beta$)} \\\\\n    & z \\in \\mathbb{B} \\\\\n    & x, y \\geq 0.\n\\end{align*}\n\\]\nwhere the variable \\(z \\in \\{ 0, 1\\}\\) “activates” the constraints related to the old or new technology, respectively, and \\(M\\) is a large enough constant. It can be implemented in Pyomo as follows.\n\nm = pyo.ConcreteModel(\"Multi-Product Factory - MILP formulation\")\n\nm.profit = pyo.Var(domain=pyo.NonNegativeReals)\nm.production_x = pyo.Var(domain=pyo.NonNegativeReals)\nm.production_y = pyo.Var(domain=pyo.NonNegativeReals)\n\nm.z = pyo.Var(domain=pyo.Binary)\nM = 10000\n\n@m.Objective(sense=pyo.maximize)\ndef maximize_profit(m):\n    return m.profit\n\n@m.Constraint()\ndef profit_constr_1(m):\n    return m.profit &lt;= 40 * m.production_x + 30 * m.production_y + M * m.z\n\n@m.Constraint()\ndef profit_constr_2(m):\n    return m.profit &lt;= 45 * m.production_x + 30 * m.production_y + M * (1 - m.z)\n    #return m.profit &lt;= 30 * m.production_x + 30 * m.production_y + M * (1 - m.z)\n\n@m.Constraint()\ndef demand(m):\n    return m.production_x &lt;= 40\n\n@m.Constraint()\ndef laborA(m):\n    return m.production_x + m.production_y &lt;= 80\n\n@m.Constraint()\ndef laborB_1(m):\n    return 2 * m.production_x + m.production_y &lt;= 100 + M * m.z\n\n@m.Constraint()\ndef laborB_2(m):\n    return 1.5 * m.production_x + m.production_y &lt;= 100 + M * (1 - m.z)\n\n\nSOLVER.solve(m, tee=True)\n\nprint(f\"Profit = ${pyo.value(m.maximize_profit):.2f}\")\nprint(f\"Production X = {pyo.value(m.production_x)}\")\nprint(f\"Production Y = {pyo.value(m.production_y)}\")\n\nRunning HiGHS 1.10.0 (git hash: fd86653): Copyright (c) 2025 HiGHS under MIT licence terms\nMIP  has 6 rows; 4 cols; 17 nonzeros; 1 integer variables (1 binary)\nCoefficient ranges:\n  Matrix [1e+00, 1e+04]\n  Cost   [1e+00, 1e+00]\n  Bound  [1e+00, 1e+00]\n  RHS    [4e+01, 1e+04]\nPresolving model\n5 rows, 4 cols, 16 nonzeros  0s\n5 rows, 4 cols, 16 nonzeros  0s\n\nSolving MIP model with:\n   5 rows\n   4 cols (1 binary, 0 integer, 0 implied int., 3 continuous)\n   16 nonzeros\n\nSrc: B =&gt; Branching; C =&gt; Central rounding; F =&gt; Feasibility pump; H =&gt; Heuristic; L =&gt; Sub-MIP;\n     P =&gt; Empty MIP; R =&gt; Randomized rounding; S =&gt; Solve LP; T =&gt; Evaluate node; U =&gt; Unbounded;\n     z =&gt; Trivial zero; l =&gt; Trivial lower; u =&gt; Trivial upper; p =&gt; Trivial point; X =&gt; User solution\n\n        Nodes      |    B&B Tree     |            Objective Bounds              |  Dynamic Constraints |       Work      \nSrc  Proc. InQueue |  Leaves   Expl. | BestBound       BestSol              Gap |   Cuts   InLp Confl. | LpIters     Time\n\n         0       0         0   0.00%   4200            -inf                 inf        0      0      0         0     0.0s\n R       0       0         0   0.00%   4200            2600              61.54%        0      0      0         2     0.0s\n C       0       0         0   0.00%   3000            3000               0.00%        6      2      0         8     0.0s\n T       0       0         0   0.00%   3000            3000               0.00%        6      2      0         8     0.0s\n         1       0         1 100.00%   3000            3000               0.00%        6      2      0         8     0.0s\n\nSolving report\n  Status            Optimal\n  Primal bound      3000\n  Dual bound        3000\n  Gap               0% (tolerance: 0.01%)\n  P-D integral      0.000290254989245\n  Solution status   feasible\n                    3000 (objective)\n                    0 (bound viol.)\n                    8.881784197e-16 (int. viol.)\n                    0 (row viol.)\n  Timing            0.00 (total)\n                    0.00 (presolve)\n                    0.00 (solve)\n                    0.00 (postsolve)\n  Max sub-MIP depth 0\n  Nodes             1\n  Repair LPs        0 (0 feasible; 0 iterations)\n  LP iterations     8 (total)\n                    0 (strong br.)\n                    6 (separation)\n                    0 (heuristics)\nProfit = $3000.00\nProduction X = 40.0\nProduction Y = 40.0",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Example 1: Disjunctions - Theory, Examples</span>"
    ]
  },
  {
    "objectID": "examples/01-Disjunctions.html#disjunctive-programming-implementation",
    "href": "examples/01-Disjunctions.html#disjunctive-programming-implementation",
    "title": "Example 1: Disjunctions - Theory, Examples",
    "section": "Disjunctive programming implementation",
    "text": "Disjunctive programming implementation\nAlternatively, we can formulate our problem using a disjunction, preserving the logical structure, as follows:\n\\[\n\\begin{align*}\n\\max \\quad & \\text{profit}\\\\\n\\text{s.t.} \\quad\n& x  \\leq 40 & \\text{(demand)}\\\\\n& x + y  \\leq 80 & \\text{(labor A)} \\\\\n& \\begin{bmatrix}\n    \\text{profit} = 40x + 30y\\\\\n    2 x + y \\leq 100\n\\end{bmatrix}\n\\veebar\n\\begin{bmatrix}\n    \\text{profit} = 45x + 30y\\\\\n    1.5 x + y \\leq 100\n    \\end{bmatrix}\\\\\n& x, y \\geq 0.\n\\end{align*}\n\\]\nThis formulation has the benefit that the solver can intelligently partition the problem’s solution into various sub-cases, based on the given disjunction. Pyomo natively supports disjunctions, as illustrated in the following implementation.\n\nm = pyo.ConcreteModel(\"Multi-Product Factory - Disjunctive Programming\")\n\nm.profit = pyo.Var(bounds=(-1000, 10000))\nm.x = pyo.Var(domain=pyo.NonNegativeReals, bounds=(0, 1000))\nm.y = pyo.Var(domain=pyo.NonNegativeReals, bounds=(0, 1000))\n\n@m.Objective(sense=pyo.maximize)\ndef maximize_profit(m):\n    return m.profit\n\n@m.Constraint()\ndef demand(m):\n    return m.x &lt;= 40\n\n@m.Constraint()\ndef laborA(m):\n    return m.x + m.y &lt;= 80\n\n# Define a disjunction using Pyomo's Disjunction component\n# The 'xor=True' indicates that only one of the disjuncts must be true\n@m.Disjunction(xor=True)\ndef technologies(m):\n    # The function returns a list of two disjuncts\n    # each containing a profit and a constraint\n    return [\n        [m.profit == 40 * m.x + 30 * m.y, 2 * m.x + m.y &lt;= 100],\n        [m.profit == 45 * m.x + 30 * m.y, 1.5 * m.x + m.y &lt;= 100],\n    ]\n\n# Transform the Generalized Disjunctive Programming (GDP) model using\n# the big-M method into a MILP problem and solve it\npyo.TransformationFactory(\"gdp.bigm\").apply_to(m)\nSOLVER.solve(m, tee=True)\n\nprint(f\"Profit = ${pyo.value(m.maximize_profit):.2f}\")\nprint(f\"Production X = {pyo.value(m.x)}\")\nprint(f\"Production Y = {pyo.value(m.y)}\")\n\nRunning HiGHS 1.10.0 (git hash: fd86653): Copyright (c) 2025 HiGHS under MIT licence terms\nMIP  has 9 rows; 5 cols; 27 nonzeros; 2 integer variables (2 binary)\nCoefficient ranges:\n  Matrix [1e+00, 8e+04]\n  Cost   [1e+00, 1e+00]\n  Bound  [1e+00, 1e+04]\n  RHS    [1e+00, 8e+04]\nPresolving model\n7 rows, 4 cols, 24 nonzeros  0s\n7 rows, 4 cols, 24 nonzeros  0s\n\nSolving MIP model with:\n   7 rows\n   4 cols (1 binary, 0 integer, 0 implied int., 3 continuous)\n   24 nonzeros\n\nSrc: B =&gt; Branching; C =&gt; Central rounding; F =&gt; Feasibility pump; H =&gt; Heuristic; L =&gt; Sub-MIP;\n     P =&gt; Empty MIP; R =&gt; Randomized rounding; S =&gt; Solve LP; T =&gt; Evaluate node; U =&gt; Unbounded;\n     z =&gt; Trivial zero; l =&gt; Trivial lower; u =&gt; Trivial upper; p =&gt; Trivial point; X =&gt; User solution\n\n        Nodes      |    B&B Tree     |            Objective Bounds              |  Dynamic Constraints |       Work      \nSrc  Proc. InQueue |  Leaves   Expl. | BestBound       BestSol              Gap |   Cuts   InLp Confl. | LpIters     Time\n\n         0       0         0   0.00%   4200            -inf                 inf        0      0      0         0     0.0s\n R       0       0         0   0.00%   4200            2600              61.54%        0      0      0         2     0.0s\n C       0       0         0   0.00%   3000            3000               0.00%        6      2      0         8     0.0s\n         1       0         1 100.00%   3000            3000               0.00%        6      2      0         8     0.0s\n\nSolving report\n  Status            Optimal\n  Primal bound      3000\n  Dual bound        3000\n  Gap               0% (tolerance: 0.01%)\n  P-D integral      0.00028999664704\n  Solution status   feasible\n                    3000 (objective)\n                    0 (bound viol.)\n                    0 (int. viol.)\n                    0 (row viol.)\n  Timing            0.00 (total)\n                    0.00 (presolve)\n                    0.00 (solve)\n                    0.00 (postsolve)\n  Max sub-MIP depth 0\n  Nodes             1\n  Repair LPs        0 (0 feasible; 0 iterations)\n  LP iterations     8 (total)\n                    0 (strong br.)\n                    6 (separation)\n                    0 (heuristics)\nProfit = $3000.00\nProduction X = 40.0\nProduction Y = 40.0\n\n\n\nAlternative solver\nTry with the cbc solver…\n\nsolver = 'cbc'\nSOLVER = pyo.SolverFactory(solver)\n\nSOLVER.solve(m, tee=True)\n\nprint(f\"Profit = ${pyo.value(m.maximize_profit):.2f}\")\nprint(f\"Production X = {pyo.value(m.x)}\")\nprint(f\"Production Y = {pyo.value(m.y)}\")\n\nWelcome to the CBC MILP Solver \nVersion: 2.10.12 \nBuild Date: Mar  5 2025 \n\ncommand line - /opt/miniconda3/envs/exa-atow/bin/cbc -printingOptions all -import /var/folders/kx/_1g1vzv51nq1yv81c377flsr0000gn/T/tmpt98ljm9h.pyomo.lp -stat=1 -solve -solu /var/folders/kx/_1g1vzv51nq1yv81c377flsr0000gn/T/tmpt98ljm9h.pyomo.soln (default strategy 1)\nOption for printingOptions changed from normal to all\n CoinLpIO::readLp(): Maximization problem reformulated as minimization\nCoin0009I Switching back to maximization to get correct duals etc\nPresolve 7 (-2) rows, 4 (-1) columns and 24 (-3) elements\nStatistics for presolved model\nOriginal problem has 2 integers (2 of which binary)\nPresolved problem has 1 integers (1 of which binary)\n==== 3 zero objective 2 different\n3 variables have objective of -0\n1 variables have objective of 1\n==== absolute objective values 2 different\n3 variables have objective of 0\n1 variables have objective of 1\n==== for integers 1 zero objective 1 different\n1 variables have objective of -0\n==== for integers absolute objective values 1 different\n1 variables have objective of 0\n===== end objective counts\n\n\nProblem has 7 rows, 4 columns (1 with objective) and 24 elements\nColumn breakdown:\n0 of type 0.0-&gt;inf, 2 of type 0.0-&gt;up, 0 of type lo-&gt;inf, \n1 of type lo-&gt;up, 0 of type free, 0 of type fixed, \n0 of type -inf-&gt;0.0, 0 of type -inf-&gt;up, 1 of type 0.0-&gt;1.0 \nRow breakdown:\n0 of type E 0.0, 0 of type E 1.0, 0 of type E -1.0, \n0 of type E other, 1 of type G 0.0, 0 of type G 1.0, \n1 of type G other, 1 of type L 0.0, 0 of type L 1.0, \n4 of type L other, 0 of type Range 0.0-&gt;1.0, 0 of type Range other, \n0 of type Free \nContinuous objective value is 7900 - 0.00 seconds\nCgl0003I 0 fixed, 0 tightened bounds, 1 strengthened rows, 0 substitutions\nCgl0004I processed model has 7 rows, 4 columns (1 integer (1 of which binary)) and 24 elements\nCbc0038I Initial state - 1 integers unsatisfied sum - 0.49\nCbc0038I Pass   1: suminf.    0.00000 (0) obj. 3000 iterations 1\nCbc0038I Solution found of 3000\nCbc0038I Relaxing continuous gives 3000\nCbc0038I Before mini branch and bound, 0 integers at bound fixed and 1 continuous\nCbc0038I Full problem 7 rows 4 columns, reduced to 5 rows 3 columns\nCbc0038I Mini branch and bound improved solution from 3000 to 3000 (0.00 seconds)\nCbc0038I Round again with cutoff of 3490\nCbc0038I Pass   2: suminf.    0.04900 (1) obj. 3490 iterations 1\nCbc0038I Pass   3: suminf.    0.06900 (1) obj. 3490 iterations 6\nCbc0038I Pass   4: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass   5: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass   6: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass   7: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass   8: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass   9: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  10: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  11: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  12: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  13: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  14: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  15: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  16: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  17: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  18: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  19: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  20: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  21: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  22: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  23: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  24: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  25: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  26: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  27: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  28: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  29: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  30: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I Pass  31: suminf.    0.06900 (1) obj. 3490 iterations 0\nCbc0038I No solution found this major pass\nCbc0038I Before mini branch and bound, 0 integers at bound fixed and 1 continuous\nCbc0038I Full problem 7 rows 4 columns, reduced to 5 rows 3 columns\nCbc0038I Mini branch and bound did not improve solution (0.00 seconds)\nCbc0038I After 0.00 seconds - Feasibility pump exiting with objective of 3000 - took 0.00 seconds\nCbc0012I Integer solution of 3000 found by feasibility pump after 0 iterations and 0 nodes (0.00 seconds)\nCbc0031I 2 added rows had average density of 3\nCbc0013I At root node, 10 cuts changed objective from 7900 to 3000 in 1 passes\nCbc0014I Cut generator 0 (Probing) - 5 row cuts average 2.8 elements, 0 column cuts (0 active)  in 0.000 seconds - new frequency is 1\nCbc0014I Cut generator 1 (Gomory) - 1 row cuts average 4.0 elements, 0 column cuts (0 active)  in 0.000 seconds - new frequency is 1\nCbc0014I Cut generator 2 (Knapsack) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.000 seconds - new frequency is -100\nCbc0014I Cut generator 3 (Clique) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.000 seconds - new frequency is -100\nCbc0014I Cut generator 4 (MixedIntegerRounding2) - 2 row cuts average 2.0 elements, 0 column cuts (0 active)  in 0.000 seconds - new frequency is 1\nCbc0014I Cut generator 5 (FlowCover) - 0 row cuts average 0.0 elements, 0 column cuts (0 active)  in 0.000 seconds - new frequency is -100\nCbc0014I Cut generator 6 (TwoMirCuts) - 2 row cuts average 2.0 elements, 0 column cuts (0 active)  in 0.000 seconds - new frequency is -100\nCbc0001I Search completed - best objective 3000, took 0 iterations and 0 nodes (0.00 seconds)\nCbc0035I Maximum depth 0, 0 variables fixed on reduced cost\nCuts at root node changed objective from 7900 to 3000\nProbing was tried 1 times and created 5 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nGomory was tried 1 times and created 1 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nKnapsack was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nClique was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nMixedIntegerRounding2 was tried 1 times and created 2 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nFlowCover was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nTwoMirCuts was tried 1 times and created 2 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\nZeroHalf was tried 1 times and created 0 cuts of which 0 were active after adding rounds of cuts (0.000 seconds)\n\nResult - Optimal solution found\n\nObjective value:                3000.00000000\nEnumerated nodes:               0\nTotal iterations:               0\nTime (CPU seconds):             0.00\nTime (Wallclock seconds):       0.01\n\nTotal time (CPU seconds):       0.00   (Wallclock seconds):       0.01\n\nProfit = $3000.00\nProduction X = 40.0\nProduction Y = 40.0",
    "crumbs": [
      "Implementation",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Example 1: Disjunctions - Theory, Examples</span>"
    ]
  }
]